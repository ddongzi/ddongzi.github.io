---
layout: post        # 必须指定布局，通常是 post 或 page
title: "linux"    # 显示在侧边栏和页面顶部的标题
description: "linux环境和网络编程"  # 可选，用于 SEO 或搜索预览
---


# 未分类

# unistd.h

*<unistd.h> UNIX standard header* 主要就是UNIX系统级接口：进程，IO, 文件描述符，系统调用

类型：pid_t, uid_t, size_t, ssize_t, off_t, intptr_t, stdin-0,..

进程：fork, exec*, getpid, _exit, getppid

文件与IO：open, read,.. fsync, pipe

目录: rmdir, chdir, getcwd

用户：getuid..

系统控制：sleep, alarm, pause, sysconf





# errno

*error.h*

| errno                 | 典型原因                                                     |
| --------------------- | ------------------------------------------------------------ |
| *EINTR*               | 执行阻塞操作时候，如epoll_wait，此时需要处理一个信号，内核就会中断这个阻塞的系统调用，并且立即返回，设置errno为EINTR |
| *EAGAIN, EWOULDBLOCK* | 非阻塞IO没有数据可读，或缓冲区已满                           |
| *EADDRINUSE*          | 端口占用。 进程没退或者没有设置`SO_REUSEADDR`                |
| *EPIPE*               | broken pipe.  接收方已经关闭连接，但你还要发送               |



# 信号

| 信号               | 典型原因                                         |
| ------------------ | ------------------------------------------------ |
| *SIGINT*           | *CTRL + C*                                       |
| SIGKILL            | `kill -9`                                        |
| *SIGSEGV*          | 段错误，访问非法内存                             |
| *SIGALRM*          | 定时器`alarm()`到期                              |
| *SIGTERM*          | 正常的结束。`kill` 默认信号                      |
| *SIGCHLD*          | 子进程结束。父亲用它来捕获`wait()`回收该僵尸进程 |
| *SIGPIPE*          | 向已经断开的连接写数据。**网络程序必须处理**     |
| *SIGUSR1, SIGUSR2* |                                                  |
| *SIGABRT*          | 内存写穿                                         |



# 文件







create

## File对象

### FILE和fd

1. 转换

`int fd = fileno(fp)`

`FILE *fp=fdopen(fd, 'w')`

FILE对象相对fd, write这些系统调用多了缓冲区。

### *fopen*

*fopen*标志符：

- `r` 只读。
- `w` 只写。 如果文件不存在，创建。清空写
- `a` 追加。如果文件不存在，创建。追加写
- `r+` 和 `w+` 都是读写。前者必须文件存在，后者不存在则创建（但是目录必须存在）。
- `a+` 读写。写入操作追加。
- `t` 默认文本模式。对换行符转变，如*\n* 为*\r\n*
- `b` 二进制模式。原样写入。
  - Linux上`t` 和`b` 没有区别。对于一些二进制文件如.db 还是建议以`b`标识

对应于*open*:

`O_RDONLY`, `O_RDWR`,`O_WONLY`,`O_CREATE`,`O_TRUNC`,`O_APPEND`

 

*fwrite* 返回的是写入的元素个数，第三个参数

fwrite(..size, n,..) 初衷：就是为了自动计算数组结构体等的写入。

char buf[1024];

fwrite(buf, 1, 1024, fp);

DB db[5];

fwrite(db, sizeof(DB), 5, fp);



## 读入-修改-写回

文件系统不支持直接在文件插入/删除，一般通过读源文件=临时文件=写回。

比如说：一个配置文件动态修改。



## 临时文件

`tmpfile()` 就是临时使用 舍弃的。不能进行cp等

# 文件 IO

## fd

fcntl描述符控制。

`O_RDONLY`, `O_RDWR`,`O_WONLY`,`O_CREATE`,`O_TRUNC`,`O_APPEND`

> 对于一个一直打开的描述符，我们应该再其打开时候就确定了最大权限。





## 设置非阻塞io

```c
 #include <fcntl.h>
 int set_nonblocking(int fd) {
   int flags = fcntl(fd, F_GETFL, 0);
   if (flags == -1) return -1;
   return fcntl(fd, F_SETFL, flags | O_NONBLOCK);
 }
```



# 文件和目录

## 权限

常见权限数字： 

- 0600：创建者可读写 
- 0644：自己读写，别人只读 
- 0666：所有人读写

## stat结构体

*struct stat*存储文件或目录状态信息。

```c
#include <sys/stat.h>
struct stat {
   dev_t   st_dev;   // 文件所在设备的 ID
   ino_t   st_ino;   // 文件的 inode 编号
   mode_t   st_mode;   // 文件类型和权限
   nlink_t  st_nlink;  // 文件的硬链接数
   uid_t   st_uid;   // 文件所有者的用户 ID
   gid_t   st_gid;   // 文件所有者的组 ID
   dev_t   st_rdev;   // 如果文件是设备文件，则是设备类型
   off_t   st_size;   // 文件的字节数
   blkcnt_t  st_blocks;  // 文件占用的块数（每块 512 字节）
   time_t   st_atime;  // 上次访问时间
   time_t   st_mtime;  // 上次修改时间
   time_t   st_ctime;  // 上次状态改变时间
   // ...
};
```

- 用法1：通过stat()获取状态。如文件大小、修改时间

  ``` c
  stat("example.txt", &st)
  fstat()：//获取已经打开的文件描述符对应文件的状态，避免路径解析的开销。
  ```

- 用法2：文件类型判断宏

  ```c
  if (S_ISDIR(st.st_mode)) {
    printf("It is a directory.\n");
  } else if (S_ISREG(st.st_mode)) {
    printf("It is a regular file.\n");
  }
  ```

  

## rename



## unlink删除文件

rm命令实现的系统调用，删除文件。实际上是接触访问链。（linux文件系统机制Innode）

## ftruncate

指定文件长度



## 缓冲和落盘

对于fd类低级IO接口，无缓冲直接进行直接系统调用，进入内核缓冲

对于file类高级IO接口，由c库进行缓存，再进行系统调用，进入内核缓冲。

高级IO接口，数据流动：

用户态缓冲区(如glibc)：由c库维护。通过`fflush(file)` 将c库缓冲推送到内核缓冲区。

内核缓冲区：由操作系统维护。通过`fsync(fd)`将内核缓冲落盘

# 标准IO库 `<stdio>`

`ferror(fp)`, `feof(fp)`



# 进程

- 内存空间：独立。子进程拥有父进程的副本，互不干扰
- 稳定性：强隔离。子进程崩溃通常不会导致父进程也崩溃
- 通信机制：IPC进程间通信，如信号、管道、消息队列
- 资源开销：大

`fork()` `wait()` `SIGCHLD`

```
for (size_t i = 0; i < 10; i++) {
     pid_t pid;
     if ((pid = fork()) == 0) {
       worker_process_func();
       exit(0); // 🦀必须exit显示退出，否则后面就是子进程fork
     } else if (pid < 0)
     {
       printf("Fork failed\n");
     } 
  }
   for (size_t i = 0; i < 10; i++)
  {
     /* code */
     wait(NULL); // 🦀父进程必须显示处理子进程退出状态：sigchild信号或者wait。不然就会称为僵尸进程。即便父进程关了，子进程的父亲是1了，称为孤儿进程。
  }
}
```

## 会话

建立一个新会话setsid()

如果进程是进程组组长，出错。一般先调用fork，然后使父进程终止。子进程即继承进程组ID，但不是进程组组长。

如果进程不是进程组组长，则创建新会话成功。具体地：

该进程成为会话首进程。

该进程成为一个新进程组的组长。

该进程没有控制终端。

## 守护进程

系统守护进程

cron：定期日期执行。

初始化守护进程

```
if((pid = fork()) < 0)
err_quit("%s: can't fork", cmd);
else if(pid != 0) /* parent */
exit(0);
setsid();
sa.sa_handler = SIG_IGN; 
sigemptyset(&sa.sa_mask);
sa.sa_flags = 0; 
if(sigaction(SIGHUP, &sa, NULL) < 0) { 
err_quit("%s : can't ignore SIGHUP", cmd); 
}
```

## 写时复制copy-on-write

**在fork子进程时候，不会直接复制内存，而是父子进程共享内存页，这些共享内存页标记只读，父进程或者子进程修改内存页，触发写时复制。** 

子进程尝试修改共享内存页，操作系统触发页故障，为子进程创建该页副本再修改，且只属于子进程，只对子进程可见。 同理，父进程一样。 

**这就相当于子进程得到了瞬间的内存快照。**

比如：初始状态。共享内存页： *[A, B, C]* 内容 ：*["foo", "bar", "baz"]*

子进程修改B页的bar为bor。 

父亲内存页：*[A, B, C]* *，子内存页：*[A, B' , C]* 

父内容：*["foo", "bar", "baz"]*,   子内容 ：*["foo", "bor", "baz"]*



# 高级IO

## IO多路转接

while((n = read(STDIN_FILENO, buf, BUFSIZ)) > 0) 

  if(write(STDOUT_FILENO, buf, n) != n)

​    err_sys("wrtite error");

需求：从两个描述符读，可能会阻塞在一个读IO上，导致另外的描述符也不能读。也不知道到底哪个输入会得到数据 IO多路转接：构造一个感兴趣的描述符表，调用一个函数，直到其中一个描述符已经准备好，该函数才返回。 poll , select, pselect ， 返回后 进程会得知哪些描述符已经准备好。 然后就可以正确调用IO read , write 

## Select

int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);

fd_set rset;

int fd;

FD_ZERO(&rset);

FD_SET(fd, &rset);

FD_SET(STDIN_FILENO, &rset);

| 参数              | 说明                                                         |
| ----------------- | ------------------------------------------------------------ |
| nfds              | 表示三个描述符集最大值加1.                                   |
| readfds, writefds | 表示感兴趣的  读写。 每个描述符为一位。                      |
| exceptfds         | 监听异常事件（如 OOB 数据）                                  |
| timeout           | 超时控制，决定 select 阻塞时间，NULL 表示无限等待            |
| 返回值            | -1表示出错， 0表示描述符都没有准备好（读集合中读不会阻塞，写集合写不会阻塞) 大于0为准备好的描述符个数 |

## Fd_set操作

文件描述符集合，存储需要监听的文件描述符。

| 宏                  | 作用                                     |
| ------------------- | ---------------------------------------- |
| FD_ZERO(&set)       | 清空 fd_set 集合                         |
| FD_SET(fd,  &set)   | 将 fd 添加到 fd_set                      |
| FD_CLR(fd,  &set)   | 从 fd_set 中移除 fd                      |
| FD_ISSET(fd,  &set) | 检查 fd 是否在 fd_set 中（即是否准备好） |

使用示例

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/select.h>
 
int main() {
fd_set read_fds; // 可读事件监听集合
struct timeval timeout;
int fd = STDIN_FILENO; // 监听标准输入（键盘输入）
FD_ZERO(&read_fds);  // 清空集合
FD_SET(fd, &read_fds); // 将标准输入加入监听集合
timeout.tv_sec = 5;  // 设置超时 5 秒
timeout.tv_usec = 0;
printf("等待输入，5 秒后超时...\n");
int ret = select(fd + 1, &read_fds, NULL, NULL, &timeout);
if (ret == -1) {
perror("select 出错");
return 1;
} else if (ret == 0) {
printf("超时，无输入\n");
} else {
if (FD_ISSET(fd, &read_fds)) {
char buffer[100];
read(fd, buffer, sizeof(buffer));
printf("输入内容：%s\n", buffer);
}
}
return 0;
}
```

###  要点

select 会修改 fd_set，需要每次重新设置。（因为会清除未发生变化的描述符）

timeout每次也要重新设置

最多能监听102个描述符

## epoll

- 事件驱动：注册的fd，不会每次遍历所有fd。而是只关心发生变化的fd，epoll_wait也只返回有事件的fd，而不是select需要遍历
- 支持边缘触发ETL模式：减少重复

创建epoll实例：epoll_create1

支持边缘触发ETL模式：减少重复通知

### 用法

- 创建epoll实例：epoll_create1

- 添加、修改、删除 fd : `int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);`
  - epfd: epoll实例
  - op：操作。EPOLL_CTL_ADD，EPOLL_CTL_MOD ，EPOLL_CTL_DEL 
  - fd：要监听的文件描述符

### epoll事件

一方面，`_ctl`时候用到；一方面，`_wait`会返回。

- epoll_event：表示一个fd上的事件。epoll_data携带数据

```c
 struct epoll_event   {
     uint32_t events; // 事件类型（EPOLLIN、EPOLLOUT、EPOLLERR、EPOLLET）
     epoll_data_t data; // 存储用户数据（通常是文件描述符）
 };
```

*events* 用位掩码说明事件类型/返回状态。

- `EPOLLERR`: *_wait* 返回时候会设置，表示有错误发生。
  - 
- 



```c
struct epoll_event event;
event.events = EPOLLIN; // 监听可读事件
event.data.fd = socket_fd;
if (epoll_ctl(epfd, EPOLL_CTL_ADD, socket_fd, &event) ==   -1) {
    perror("epoll_ctl:   EPOLL_CTL_ADD");
    exit(EXIT_FAILURE);
}
```

### 等待

` int epoll_wait(int epfd,struct epoll_event *events, int maxevents, int timeout);`

- events 存储触发事件的数组。最多为maxevents

- *timeout(mill sec)*: >0 超时等待时间。-1阻塞等待。0立即返回。

- return : >0 触发的事件数量。对应events数组里面就绪的fd。0超时，无发生。-1错误 errno获取.
   比如监听了 fd 1，3，4，5 。 其中1，4有事件，那么nfds返回2. events[0].data.fd=1， events[1].data.fd=4。即返回有事件fd的event，填充进events数组。

  ```C
   struct epoll_event events[64]; 
   int nfds = epoll_wait(epfd, events, 64, -1); 
   if (nfds == -1) perror("epoll_wait");
  ```

- 在等待网络事件时候，操作系统经常需要处理其他请求/信号，就需要EINTR中断

## ET模式

LT：只要fd可读/可写，每次wait都会返回该fd

ET:只在状态改变时候通知。减少epoll_wait唤醒次数。

问题

accpet后 epoll_ctl常出现 no such file 问题，不能epool fd。？

就是对方accept后瞬间有关闭了。瞬间连接-断开，更多是正常现象（健康检查/探测/测试），小概率是异常现象。服务器端必须容忍。

client connect() 成功只是TCP的三次握手完成。 真正连接是否健康，要通过后续的 read/write 感知。 比如发送ping，

会一直阻塞在recv上，可以设置超时重试

如果对端正常关闭，epoll会短时内一直一直就绪。

# 记录锁

多个人同时编辑一个文件，结果如何？

一般的，会取决于写该文件的最后一个进程。但是对于数据库，只能一个写。

记录锁：一个进程读或者修改文件某个区域，阻止其他进程同时修改这一区域。

int fcntl(int fd, int cmd, struct flock *ptr);

cmd : F_GETLK 测试是否能建立一把锁（很少用）。F_SETLK加锁。F_SETLKW阻塞式加锁，即如果文件已经加锁，该进程就会休眠阻塞。

flock : 表明锁类型（共享读锁、独占写锁、解锁一个区域）。加解锁区域。相关进程PID。

加解锁时，会组合或分裂区域。

 

案例：请求和释放一把锁：

```
#define read_lock(fd, offset, whence, len) lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))
#define readw_lock(fd, offset, whence, len) lock_reg((fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))
#define write_lock(fd, offset, whence, len) lock_reg((fd), F_SETLK, F_WRLCK, (offset), (whence), (len))
#define writew_lock(fd, offset, whence, len) lock_reg((fd), F_SETLKW, F_WRLCK, (offset), (whence), (len))
#define un_lock(fd, offset, whence, len) lock_reg((fd), F_SETLK, F_UNLCK, (offset), (whence), (len))
 
int lock_reg(int fd, in tcmd, int type, off_t offset, int whence, off_t len)
{
struct flock lock;
lock.l_type = type; /* F_RDLCK, F_WRLCK, F_UNLCK*/
lock.l_start = offset;
lock.l_whence = whence;
lock.l_len = len; /*##bytes (o means to EOF)*/
return fcntl(fd, cmd, &lock);
 
}
```

# 线程

- 内存：所有线程共享全局变量、文件描述符
- 隔离：子线程可能会导致整个进程崩溃
- 通信：直接通过共享变量通信，同步上锁

## 一些注意：

1. 在持有mutex的情况下，做IO。如write/fsync.  ❌
   - 做io会阻塞。期间，所有要唤醒这个线程的 都卡死了。（IO不要放在锁内）
   - 锁只能保护状态而不保护IO。 即 lock-状态-unlock, IO, lock-更新状态-unlock
2. *swap*：在持锁的状态下，把正在写的缓冲区和即将刷盘的缓冲区交换指针。
   - 场景：比如一个线程需要周期将缓冲刷到文件，最简单就是 整个加锁。我们期待：**让刷盘的这个线程拿到冻结数据去io，同时不阻塞生产者继续写日志。**

## 主要概念

- `pthread_create`：返回值为错误码`errno`
- `pthread_exit`主动结束
- `pthread_join`等待线程结束

### 分离线程

默认情况下，线程状态一直保存到`pthread_join`。如果分离状态，线程执行完即立即收回资源。

两种方法。

- `pthread_detach`：

- 分离状态：主线程不需要线程的终止状态时候，即可将其分离。比如网络线程。
  ```c
  pthread_attr_t attr;
  pthread_attr_init(&attr);
  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
  ```



## 线程同步

### 条件变量

- 线程改变条件状态时候必须锁住互斥量

`pthread_cond_init`

`pthread_cond_wait(cond, mutex)` mutex是外层锁住的互斥量；线程进入睡眠状态。

`pthread_cond_signal(cond)` 唤醒

- 情况：可能signal先发生，而wait后执行，那么就会一直休眠。所以应该.。*while( !shouldflush) {cond_wait}*
- 

### 屏障

> 比如并发测试时候，10个线程对一个count增加， 很可能是默认执行相差一些时间，就会导致是串行，得不到结果。我们可以设置一个集合点（屏障），等待所有人到达，再一起count增加。更加模拟高频竞争。

`pthread_barrier_init(barrier, attr, count)`

- *count* 允许所有线程继续运行之前，必须到达屏障的线程数目

`pthread_barrier_wait(barrier)`

- 表明线程已经完成工作到达屏障，等待其他线程
- 当最后一个线程调用，满足屏障计数了，此时所有线程唤醒。

`pthread_barrier_destroy(barrier)`

**例子**: 







##  线程模型

1. 常驻线程：
- 通过队列/条件变量接受任务。
- 例子：日志、

2. 线程池：

- 由固定数量线程竞争执行任务
- 例子：web服务

3. 生产者-消费者模型：

- 一组线程生产任务，一组线程消费任务
- 例子：并发系统？

4. 流水线模型：

- 多阶段，每个阶段安排一线程。

5. 主从模型：

- master分发任务，worker复杂执行任务

6. reactor模型：



## 线程控制

### 死锁分析



## 竞态条件

几种常见情形：

1. *check-then-act* **检查后执行**

- 准备执行时候，之前检查的条件可能已经不在成立了。
- *check*: `if (x==1)`； *act*: `x=2` 。在check和act之间，存在时间间隙，可能另外一个线程就已经修改了变量，导致动作是不应该发生。

2. *read-modify-write* **读改写**

- 发生在对变量自增/自减。读到寄存器修改，再写回内存。
- 两个线程同时读取`count=10`， 自己在本地`+1`得到11写回内存。但是同一个寄存器，实际上是对11进行+1了。

3. *lost update* **丢失更新**

- 两个线程同时更新一个数据块，后一个写入的线程覆盖了前一个的结果，没有考虑前者的改动。

4. *initialization race* **初始化竞态**

- 在初始化对象时候。
- `if (instance==NULL) {instance=newObj();}` 在单例模式中，两个线程都判断为NULL



### 同步属性：

### 互斥量属性：

默认属性初始化：pthread_mutex_t qlock = PTHREAD_MUTEX_INITIALIZER;， 或者pthread_mutex_init(&mutex, NULL)

非默认属性：pthread_mutexattr_init(attr) . pthread_mutex_init(&mutex, &attr) 先初始化设置互斥量属性，再用属性来初始化互斥量

类型属性 PTHREAD_MUTEX_RECURSIVE: 互斥量通过计数来加锁解锁。

# 内存管理

操作系统提供了mmap（分配内存）、sbrk（扩缩进程堆空间）等系统调用申请内存，但是应用层一般不会直接调用，原因有二：

系统调用提供的内存粒度太大，常常是一页4K.

频繁系统调用会增大开销。

现代应用层自己的内存分配器都是维持一片内存池，进行内存管理。

malloc的底层是glibc库的ptmalloc函数。

mmap：

将文件或内存区域映射到进程的虚拟地址空间，也可以用来直接分配内存。

含义：

虚拟地址空间：就是程序自己内存地址空间。

映射：可以将一个文件或者一块内存映射到自己的程序内存，程序就可以按照访问内存的方式访问，而不需要自己去读取。

例子：

有一个大数据库文件，程序即可通过mmap将该文件映射到自己的内存内，直接修改文件，而不需要每次还得打开读取。

# 网络编程

## 错误记录

1. 服务器挂起期间，客户端如果尝试连接，服务器在套接字上产生 `broken pipe`错误：

   - 挂起：进程暂停（STOP），系统休眠

   - 具体过程：
     - 客户端的TCP连接会因为长时间没有收到回复，**主动关闭连接**， 发送FIN或者RST
     - 虽然服务器挂起，但是内核TCP栈仍然运行，收到客户端断开请求，标记连接不可用
     - 服务器进行写操作/epoll_wait时候，内核触发错误`EPIPE`
   - 

## 地址相关结构体

- 

|                          |                                                              |                                                              |
| ------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| struct  sockaddr         | 通用地址                                                     | 不能直接用于bind，需要转为具体ipv4/6                         |
| struct  sockaddr_in      | ipv4地址                                                     | - 端口号和ip必须经过转换才能设置。htons和inet_pton - 只能用于IPV4 |
| struct  sockaddr_in6     | ipv6地址                                                     |                                                              |
| struct  addrinfo         | 解析域名返回地址表，包含IPV4，IPV6。通常，用这些地址建立socket连接。 | - 与sockaddr不同，可以直接进行兼容编程。 - 用于getaddrinfo()解析主机，获取ip |
| struct  sockaddr_storage | 给足够大的空间，IPV4/6都可以通过这个存储。通常，用这个存储accept等得到的地址 |                                                              |

## 套接字函数

## 其他辅助函数

| 函数                                                         | 含义                                      | 注意 |
| ------------------------------------------------------------ | ----------------------------------------- | ---- |
| inet_pton(AF_INET,  "127.0.0.1", &addr.sin_addr);            | IP 地址转换：字符串 -> 二进制             |      |
| inet_ntop(AF_INET,  &addr.sin_addr, ip_str, sizeof(ip_str)); | IP 地址转换：二进制 -> 字符串             |      |
| uint32_t  htonl(uint32_t hostlong);                          | 字节序转换：  主机 -> 网络字节序（32 位） |      |
| uint16_t  htons(uint16_t hostshort);                         | 字节序转换：主机 -> 网络字节序（16 位）   |      |
| uint32_t  ntohl(uint32_t netlong);                           | 字节序转换：网络 -> 主机字节序（32 位）   |      |
| uint16_t  ntohs(uint16_t netshort);                          | 字节序转换：网络 -> 主机字节序（16 位）   |      |

## 未归

- getaddrinfo()：实现具体依赖于网络库，所以在netdb.h中只是extern，并没有具体实现，真正的实现在glibc中，需要编译连接

- ***recv/read*返回值：**

  - *>0* 正常从网络缓冲区读取字计数

  - *=0* 读到EOF, 表示对端正常关闭（收到FIN报文）（对端调用了*close*)。 本地也应该close关闭

  - *=-1* 出现异常
    - *errno == EAGAIN/EWOULDBLOCK* 缓冲区没有数据可读。应该稍后重试。
    - *errno == EINTR* 被其他信号中断。应该重新*read*
    - 其他：连接故障关闭，应该close


​	通常来说，对端进程不论是kill还是异常，内核会自动回收fd，并向客户端发送FIN报文，客户端感觉对端关闭。



## 套接字选项sockopt

```c
include <sys/socket.h>
int setsockopt(int sockfd, int level, int optname, void optval[], socklen_t optlen);
int getsockopt(int sockfd, int level, int optname, void optval[], socklen_t *optlen);
```

- level: IPPROTO_TCP,SOL_SOCKET
- `optlen`: 就是 `optval`长度



常用：

1. 检测套接字上的错误。 *SO_ERROR*

   ```c
   int err = 0;
   socklen_t len = sizeof(err);
   if (getsockopt(e->data.fd, SOL_SOCKET, SO_ERROR, &err, &len) < 0)
   {
       log_debug("getsockopt failed. %s", strerror(errno));
   }
   else if (err != 0)
   {
       log_error("epoll_error on fd[%d] :%s,", e->data.fd, strerror(err));
   }
   ```

   - *err* 和*errno* 取值范围和定义一致，都在*error.h*

2. 





**SOCKET****级别的** **optname:**

- SO_REUSEADDR ：快速在同一端口重启。

 if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &(int){1}, sizeof(int)) < 0) {}

TCP连接关闭，会进入TIME_WAIT状态，等待确保所有数据能够处理。 在这个状态下，端口不能重新绑定，直到连接上没有数据包流动。

默认情况下，TIME_WAIT会持续2-4分钟。取决于操作系统配置。

并不是万能的！还是可能already in use。 lsof -i :<port>查看手动关闭

- SO_KEEPALIVE：保活开关。自动断开死链。
- SO_ERROR ：取出fd上最后一次错误。
- SO_RCVTIMEO / SO_SNDTIMEO：给阻塞套接字设置超时时间，返回EAGAIN
- 

设置rec(), write()超时时间。用于客户端超时重连。超时 errno 是 EAGAIN 或 EWOULDBLOCK。

**TCP****级的****optname:**

TCP_NODELAY：Nagle算法会将小的数据包合成大的再发，等待缓冲区满了发。 启用不能保证实时性，

TCP_KEEP** ：保活细节。
 会在连接空闲时候发生保活包检测是否连接有效，如果指定时间内没有响应就断开

TCP_KEEPIDLE：连接空闲多长时间后开始发送保活探测包（单位：秒）。

TCP_KEEPINTVL：保活探测包之间的时间间隔（单位：秒）。

TCP_KEEPCNT：在认为连接失效之前，最多发送多少个保活探测包。- 

## 问题

1. **文件****/****套接字** **用哪个？，** **write****和****send****啥区别，**

结论：就看需不需要flags。

| 函数                       | 范围                     | 区别                                       |
| -------------------------- | ------------------------ | ------------------------------------------ |
| write(fd, buf,  len)       | 适用于 文件 和  套接字， | 通用写入，不能传 flags                     |
| send(fd, buf, len,  flags) | 仅适用于 socket          | 支持 flags（如 MSG_NOSIGNAL 避免 SIGPIPE） |

FILE* 可以覆盖fd 操作吗，区别在哪？（redis io仅实现FILE）

结论：如果只操作普通文件，就FILE*， 涉及其他用fd

| 特性           | FILE* (stdio.h)                              | fd (unistd.h)                        |
| -------------- | -------------------------------------------- | ------------------------------------ |
| 是否缓冲       | 有缓冲（fwrite() 先写入缓冲区）              | 无缓冲（write() 直接写入内核）       |
| 操作级别       | 高级 API，适合一般文件 I/O                   | 底层 API，适合文件、socket、管道     |
| 使用的系统调用 | fopen() / fwrite()  / fread() / fseek()      | open() / write() /  read() / lseek() |
| 支持的对象     | 普通文件                                     | 文件、socket、管道、设备、非阻塞 I/O |
| 线程安全       | 部分操作是线程安全的（FILE* 结构体内部有锁） | 不保证线程安全（除非手动加锁）       |
| 跨平台兼容性   | 跨平台兼容性更好                             | POSIX  专属，不适用于 Windows        |

1. **文件到套接字流？**

 sendfile

# 共享内存

场景：有一个交易系统，一个终端界面显示实时信息，另一个要进行操作订单。他们两个需要共享内存 进行通信

mmap : 把文件或设备映射成内存。 比如文件转换为结构体，但是结构体不能有指针，如果操作指针即跨越进程，不允许的。

所以对于这个场景是不太适用的，更适用文件共享读写。基于共享内存的操作都是内存页，与原来文件无关。如果要落入文件，需要通过msync函数把内存页落盘。 即（内存-文件-磁盘），文件磁盘是系统内核同步的，不需要管

void *mmap(void* addr, size_t length, int prot, int flags,int fd, off_t offset);

addr: 文件映射到内存空间的起始地址。一般为NULL

length: 要多少字节数，从offset开始算起

prot: 指定该内存访问权限。PROT_READ, WRITE, EXEC, NORE

flag : 解决内存重叠。 MAP_SHARED表示写入的数据会复制同步到文件内。

fd: 表示映射的文件，一般是对应open的描述符。

offset：从文件某个偏移量开始映射。必须是PAGSIZE倍数

UNIX DOMAIN SOCKET ：本地进程通信，还是服务端客户端结构。

不通过 ip:port寻址，而是基于文件。

由于结构体含有指针，还是得序列化进行通信。

共享内存，但是不使用指针，即划定一片，然后通过offset定位所有指针。---> offset 型内存池

共享内存刷到文件：

int msync(void *addr, size_t length, int flags);

刷新addr ~ addr +len 到文件。

flags : MS_SYNC阻塞强制同步，MS_ASYNC异步

释放共享内存 , 即解除当前进程对文件的内存映射。这不会影响其他进程。

munmap(base, size);

查看mmap文件内容就是查看内存内容。





# 终端IO

终端设备是由内核的终端驱动控制的，每个终端设备有一个输入队列和输出队列

![image-20251225125000941](C:\Users\63517\Documents\notes\assets\image-20251225125000941.png)

termios结构



## 特殊字符

| 字符 | 典型值 | 说明            |
| ---- | ------ | --------------- |
| CR   | \r     | 回车；不可修改  |
| EOF  |        | 文件结束        |
| EOL  |        | 行结束          |
| INTR | ^c     | 中断信号SIGINT  |
| NL   | \n     | 换行；不可修改  |
| SUSP | ^z     | 挂起信号SIGTSTP |

- 可以修改，意味着可以修改其对应典型值



`isatty`

`ttyname`

`tcgetattr` `tcsetattr`



*stty -a /dev/tty1* 了解终端设置



## 规范模式



# 伪终端

即不是一个真正的终端设备。如：

1. 网络服务器客户端：telnet
2. 实时观看输出



# cli开发

linenoise



# 位掩码设计

位运算：and, or ,not。 很快实现功能



一个64位整数：可以同时存储64个状态。相当于把定义64个bool，

定义：

```C
#define CMD_R (1<<0) // 0001
#define CMD_W (1<<1) // 0010
#define CMD_A (1<<2) // 0100
```

组合：

`flag = CMD_R | CMD_W`

设置状态:

`flag |= CMD_I`

清除状态：

`flag &= ~CMD_ADMIN`

切换状态：

`flag ^= CLIENT_READ_ONLY`

多重检查
`if ((c->flags & (USER_AUTH | USER_WRITE)) == (USER_AUTH | USER_WRITE)) { ... }`