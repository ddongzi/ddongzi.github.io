---
title: c基础
author: dong
date: 2023-10-14
tags: 工具
---
## 未归类
1. 数组不支持变量定义数组大小，如下：未初始化数组错误。只能通过编译时常量`#define` 定义
```c
size_t maxlineLen = 128;
char line[maxlineLen] = {0};
```
2. 为啥有`puts`没有`gets`?
   被废除了，不安全。可以使用`fgets`, `getline`这类限制大小。一般使用后者不保留`\n`

3. 读写函数中有哪些外部分配，有哪些内部分配？
   内部分配的：`getline`
   外部分配的：`fgets`

4. 一直`strtok`会发生什么？
   - 最后返回`null`
   - 原始字符串破坏了，替换为`\0`

5. `fork`子进程分支如果没有`exit`会发生什么？是必须的嘛？
   是的，会发生未定义行为，且会进入父亲代码。

6. 打印没有结尾\0的 `char*`

   ```c
   printf("%.*s", len, ptr); // 打印指定长度。 常用于前面指示len的场景
   ```

7. compare mem: `mem`

8. `byte & 128 != 0`

9. `stdarg.h`

10. 
## 时间
CPU时间：程序占用CPU时间。`clock_t` ，`long`毫秒级。
正常时间：
- 微秒级：`struct timeval`；`gettimeofday()`
- 纳秒级：`struct timespec`；`clock_gettime()`
- 毫秒级：`time_t ` , `long`;  `struct tm`
场景：
1. 时间戳转换为字符串？
   - `ctime(time_t *)` ：固定格式，带换行。快速使用。
   - 如果要转为指定格式字符串，要先转为`struct tm`。
2. `time_t`和`struct tm`转换：
   - 时间戳转为tm结构：`localtime()` `gmtime()UTC的`
3. `tm`转字符串：
   - `strftime()`
4. 屏幕刷新频率？
   - 使用usleep实现，0.1s, 0.2秒感知用户输入

## 重载冗杂
sizeof并不是一个函数，而是一个操作符。
- 操作数是变量：不必加括号。     sizeof *p 获取p指针指向对象的字节数
- 操作数是类型：必须加括号。sizeof(int)     *p。
            这里含义是什么？ 强制转换int型之后 sizeof？还是int长度乘以p？ 实践：是后者。
```c
int main(){ 
  char a = '5';
  int* p = &a;                      
  int q = sizeof(int) * p;          
  printf("%d", q);                  
  return 0;                         
 }
```

## 结构体
### 柔性数组
必须作为结构体最后一个字段。
问题，redis ziplist 压缩列表希望柔性数组后面再来一个zlend末尾标记，这就会冲突！

```c
typedef struct {
  unsigned int zlbytes;  // 压缩列表总字节数
  unsigned int zltail;   // 到最后一个节点的偏移量
  unsigned short zllen;  // 压缩列表中节点数
  unsigned char entries[]; // 节点数据（变长）
unsigned int zlend;
} ziplist;
解决：额外检测zlend字段，创建内存时候，加上zlend字节。但是结构不包含
```

### 向前声明
```c
typedef struct ConnectionListener ConnectionListener;

typedef struct {
    int fd;
    ConnectionListener *listener;
    // 其他字段
} Connection;

struct ConnectionListener {
    int port;
    char *bindAddr;
    Connection *conn;
} ;
```

引起的问题，“封装”：

`pointer or reference to incomplete type "struct Pager" is not allowed C/C++(833)`

```c
// pager.h
typedef struct Pager pager;

// pager.c
struct Pager {
    int size;
};
```

```c
// main.c
#include "pager.h"
Pager* p;
p->size; 
```

在`pager.c`之外，不能直接获取字段，无法感知。只能通过函数接口访问。

```c
// pager.c
int pager_get_size(Pager* p)
{
	return p->size;
}
```

如果`pager` 作为一个模块，还有`page1.c` 等模块内部文件，需要直接访问属性。常常我们使用`pagerInt.h`作为内部头文件，提供结构体完整定义。而`pager.h`作为对外头文件，提供向前声明，封装。



### 强制结构体/变量对齐。

场景：现在pool结构后面，要跟数据区域。但是整个内存要求8字节对齐，pool结构lock属性尺寸不能保证是8字节对齐的。
```c
typedef struct {
    // meta
    uint32_t magic;
    uint32_t version;
    uint32_t cap;
    uint32_t used;
    // 
    FreeBlock freeListHead; // 空闲链表头
    //
    pthread_mutex_t lock; // 内存池锁
    // data
} Pool; 
```
解决：
`__attribute__((aligned(8)))` 是编译器的扩展语法，能够强制结构体/变量对齐。
这个叫编译器属性，不是C语言语法或者宏，一般我们通过宏展开添加`#define ALIGN8 __attribute__((aligned(8))) `
``__attribute__((aligned(8))) struct pool {};`
`int x  __attribute__((aligned(16)))`

### 位字段
官方标准是`int , unsigned int ，signed int`，没有`unsigned char`

### 一次声明
```c
struct A {};   // 定义类型 A
struct A a1;   // 创建变量 a1
struct {} a2;  // 匿名 struct，变量是 a2，不能再创建相同类型变量。  常用在结构体字段内。
```

## 预处理

前向声明，避免包含头文件。

```c
// proto.h
typedef struct Conn Conn;
// conn.h
typedef struct Conn Conn;
```



## 字符串

分配策略：`string`类函数是原地修改，内部分配吗？
除了`strdup`内部会分配，其余不会主动malloc。
`strtok, strcat`都会原地修改dest
复制：一些结构体内有`char* `属性，什么时候该直接赋值，什么时候该dump：
基本上都要dump~
`char* buf; c->buf = "aaaa";`后者常量字符串是编译时候生成在只读段的，这就是正常的指针指向。



1. `strtok` will keep a global var, so multi variable error!

```c
char* s1_tok = strtok(s1, "/");
char* s2_tok = strtok(s2, "/");
s1_tok = strtok(NULL, "/"); // line 3
s2_tok = strtok(NULL, "/")
```

line3 strtok will influence line4.

right way:

```c
char* save1,*save2;
char* s1_tok = strtok_r(s1, "/", &save1);
char* s2_tok = strtok_r(s2, "/", &save2);
s1_tok = strtok(NULL, "/", &save1); // line 3
s2_tok = strtok(NULL, "/", &save2);
```



## IO
`snprintf` 返回打印的字符数。
`printf`行缓冲行为。默认遇到`\n`或者缓冲区满才会刷新的标准输出。程序推出前会自动`fflush(stdout)`。

 下面代码， printf不会打印。因为行缓冲。
```c
int main(int argc, char const *argv[])
{
    PoolContext ctx = {NULL,-1};
    pool_create(&ctx);
    printf("??");
    signal(SIGINT, sigintHandler); // CTRL+C
    void* ptr=  pool_alloc(16, &ctx);
    uint64_t* cp = (uint64_t*)ptr;
    *cp = 0XFFFFFFFFFFFFFFFF; // 测试写入
    // pool_free(ptr, &ctx);
    while (!stop) {
        sleep(1);
    }
    puts("stopped");
    pool_close(&ctx);
    pool_cover(&ctx);
    pool_destroy(&ctx);
    return 0;
}  
```

## GLIB

[GLIB文档]()
glib是跨平台的C工具库。相关地，glibc(GNU C)是linux的标准C库，linux运行基础。

C标准分为语法和实现。
- C标准库：就是一组标准头文件，规定实现含义。
- C运行库：各平台自己实现，并添加一些扩展。比如LINUX的glibc和MS的MSVCRT
glib有6个主要模块：
- `GObject`：面向对象特性：继承、信号、属性等
- `GIO`：IO抽象（文件、流、网络）
- `GLib`：基础工具。高级数据结构、内存管理、字符串处理、时间等
- `GModule`: 跨平台动态加载模块接口？
- `GThread`: 跨平台线程API和线程池支持。
- `GMainLoop`：事件循环机制。
`GTree` 平衡二叉搜索树

## 随机
整数：
```c
int x = rand() % 100;         // 0~99
```
浮点：
```c
double r = rand() / (double)RAND_MAX;          // [0, 1)
double r2 = 90.0 + r * 20.0;                   // [90.0, 110.0)
```
时间种子：
```c
srand((unsigned(time(NULL))
```
随机字符：
```c
char c = 'A' + rand() % 26;
```
布尔值：
```
bool b = rand() & 1;
```

## ncurses
关于界面刷新和用户按键。
用户按键按下是有时长的， 如果1秒界面刷新，即意味着只有间隔1s才检测。 如果0.1秒，那就是每秒检测10次。显然会流畅很多。

## 安全信号处理
`volatile sig_atomic_t stop = 0;` 
sig_atomic_t 类型表示 对于数据的访问不会被信号中断。
volatile 用于告知编译器，该变量的值可能会在编译器无法察觉的情况下被修改（例如，由信号处理程序修改）。防止编译器不必要优化，每次都从内存读取，不可使用缓存。
```C
signal(SIGINT, sigintHandler); // CTRL+C
while (!stop) {

}
// 资源清理
```

## 指针加减

`void*`不允许加减，比如内存池通过offset  + base指针定位需要转为char*



## 退出程序
| 方式              | 场景                 | 特点                                                |
| ------------------ | -------------------- | --------------------------------------------------- |
| `return-main`      |                      | 正常退出，会执行`atexit()` 注册的**清理**函数。     |
| `exit(int status)` | 库或者子函数主动退出 | 立即终止程序，会执行`atexit()` 注册的**清理**函数。 |
| `_exit(status)`    | `fork`子进程出错调用 | 立即终止，不清理，不刷新缓冲。                      |
| `abort()`          | 致命错误，如断言失败 | 异常终止，不清理，不刷新缓冲                        |
| `raise(SIGTERM); ` |                      | 信号方式的自杀式终止，触发信号处理程序              |



## 指针

### 函数指针，函数类型使用：

方法1：

定义一个函数类型：`typedef void callback(struct EventLoop* evp, void* data);` 

指向一个函数的指针：`callback* call;` 等价于`void (*call)(struct EventLoop* evp, void* data)`

方法2：更推荐

定义一个函数指针类型：`typedef void (*callback)(struct EventLoop* evp, void* data);`

声明一个函数指针类型变量：`callback call`等价于`void (*call)(struct EventLoop* evp, void* data)`

赋值：

函数名直接赋值，赋值对象是指针：`callptr = myfunc;`等价于显示取地`callptr = &myfunc`

但不能的是 `calltype = myfunc;❌`

**结构体中形式**：

```c
typedef struct
{
    int (*parse)(void *ctx, sds *buf);  // Parse from net read. Out to upper.
    int (*encode)(void *ctx, sds *buf); // Encode from upper. Out to net.
} proto_handler_t;
```



### 优先级

`&p->r`取结构体成员地址。等价于`&(p->r)  ==  &((*p).r)`

`*p->r`访问结构体成员内容。等价于`*(p->r)`

### 整数和`void*`

一般对于端口小型整数。

```c
int callback(void* arg)
{
	int port = (intptr_t)arg;
}
int port =9988;
callback((void*)(intptr_t)port);
```

## 设计

注册-回调解耦机制。

每一层对下层直接调用，对上层进行回调。

A暴露函数声明，B实现&注册，A调用。



## 数组和指针

从《C Expert》角度来看。

### 数组和指针不可以互换



### 数组和指针可以互换

有两类情况：声明和使用。

1. 声明：外部数组`extern`声明； 数组定义（定义是声明的特殊情况）；函数参数声明；

只有在函数参数的情况下，数组形式和指针形式等价。`func(char a[]);`等价于`func(char* a);`

2. 使用：即在**表达式中使用。数组形式和指针形式等价**。`c = a[i];`等价与

常见例子：

1. 在函数调用时候，数组名和指针都行

```c
char arr1[10];
char *arr2;
//...
i = strlen(arr1);
j = strlen(arr2);
printf("%s %s", arr1, arr2);
```

```c
printf("array LOC: %x, content : %s", a, a);
```

这个是成立的， 作为函数调用，传到`printf`都是指针传递。

```c
int main1(int argc, char** argv);
int main2(int argc, char* argv[]);
```

> ‼ ANSI C RULES：
>
> 1. **表达式中的数组名被编译器当作一个指向该数组第一个元素的指针。**
> 2. 下标总是与偏移量相同。
> 3. 在函数参数的声明中，数组名被编译器当作一个指向该数组第一个元素的指针。

**对数组下标的引用总是可以写成一个指向数组初始地址的指针加上偏移量。**对数组的引用如`a[i]` 在编译时候总是被改写为`*(a + i)`。

**!!例外**:极少见情况。不能用指向第一个数组元素的指针 来等价 数组名

- `sizeof(arr)`  这里是整个数组大小。而不是指针的大小
- `&arr`取数组的地址。 ???
- 数组是一个字符串常量初始值。



## 编译&链接&运行

`a.out`  assembler output 汇编程序。 通常是ELF格式。是二进制文件，不仅仅是汇编文本。

通过nm命令查看符号表；objdump -d 命令查看汇编。

### 段

`.out`可执行文件内容就是若干段：text段、data段、bss段

- size 命令查看文件内容

<img src="https://raw.githubusercontent.com/ddongzi/ddongzi.github.io/master/assets/images/imagesimage-20250923235311022.png" style="zoom: 50%;" />

- nm命令

```c
#include <stdlib.h>
char pear[40];	// 全局，未初始化 => BSS
static double peach; // 文件内，未初始化 => bss
int mango = 123;	// 全局，已初始化 => DATA
static long melon = 2001;	// 文件内，已初始化 => data

int main(int argc, char const *argv[])	// 文本段
{
    int i = 3, j, *ip; // 局部变量不在.out文件，而是在运行时创建
    ip = malloc(sizeof(i));	// 文本段
    pear[5] = i; // 文本段
    peach = 2.0 * mango; // 文本段
    return 0; // 文本段
}
```

![image-20250924004335059](https://raw.githubusercontent.com/ddongzi/ddongzi.github.io/master/assets/images/imagesimage-20250924004335059.png)

**nm命令说明**

<地址> <符号类型> <符号>

T：文本段

D：数据段已初始化的

B：bss段未初始化的

R：只读数据。 .rodata段

U：未定义符号，从其他库文件解析

W：弱符号，可被其他符号覆盖

大写：全局可见

小写：文件内可见。

**地址**

在目标文件.o中：地址是段内偏移。

在可执行文件中：地址是链接器分配的虚拟地址，通常从0x400000开始。

在程序运行时：地址是真的物理地址（虚拟地址=>“真实”地址）

- `objdump -d` 查看汇编

![image-20250924010055272](https://raw.githubusercontent.com/ddongzi/ddongzi.github.io/master/assets/images/imagesimage-20250924010055272.png)

### 为什么是段？

链接器可以直接把文件段内容通过`mmap`直接映射加载到内存。这样内存里面就是很多个的段空间。



