---
title: bison
author: dong
date: 2025-09-17
category: complier
cover: https://sighingnow.github.io/jekyll-gitbook/assets/dinosaur.gif
---

## background

在学习SQLite过程中，SQLite中的Virtual Database Engine, 需要解释SQL语言生成字节码，执行。SQLite自行实现了Lemon的parser。我希望了解他如何执行，可以的话，build my own.

## Introduction

bison 是 yacc升级版本。

[bison](https://web.stanford.edu/class/archive/cs/cs143/cs143.1128/handouts/120%20Introducing%20bison.pdf) 将 .y 文件转为 一个 .c 的语法parser

### .y 语法文件	

```c
%{
Declarations // 声明区：c语言代码，头文件、全局变量、函数声明。这些内容会原样拷贝到.c文件
%}
Definitions	// 定义区：符号声明。 如%token NUMBER
%%
Productions // 规则：
%%
User subroutines	// 用户子程序： c代码
```

规则部分

```c
非终结符 : 产生式 { 动作代码 } 
          | 产生式 { 动作代码 }
          ;
```

```c
expr : expr '+' expr   { $$ = $1 + $3; }
     | expr '*' expr   { $$ = $1 * $3; }
     | '(' expr ')'    { $$ = $2; }
     | NUMBER          { $$ = $1; }
     ;
```

解释：

| 等价于每行前面都是 expr: 。  4个规则

创建一个expr,  通过4个产生式，

`$n`：指代右边第 n 个符号的“语义值”。

`$$`：表示左边非终结符的“语义值”。

即如果传入3+4*5.

3->规则4->expr = 3

4,5->规则2-> expr = 20

3+4*5 -> 规则1->expr = 23

> 💡 expr 可以任何词代替，常写为E

Example：后缀计算

```c
// cal.y
%{
	#include <stdio.h>
	#include <assert.h>
	static int Pop();
	static int Top();
	static void Push(int val);
	int yylex(void);
	int yyerror(const char* s);
%}

%token T_Int

%%
S	:	S E '\n' { printf("=%d\n", Top()); }
	|
	;
E	:	E E	'+'	{ Push(Pop() + Pop()); }
	|	E E '-' { int op2 = Pop(); Push(Pop() - op2); }
	|	E E '*' { Push(Pop() * Pop()); }
	| 	E E '/'	{ int op2 = Pop(); Push(Pop() / op2); }
	|	T_Int { Push(yylval); }
	;	
%%
static int stack[100], count = 0;
static int Pop()
{
	assert(count > 0);
	return stack[--count];
}
static int Top()
{
	assert(count > 0);
	return stack[count - 1];
}
static void Push(int val)
{
	assert(count < sizeof(stack) / sizeof(*stack));
	stack[count++] = val;
}
int yyerror(const char* s)
{
	fprintf(stderr, "Error: %s\n", s);
	return 0;
}
int main()
{
	return yyparse();
}
```

`yylval`: 传递发现的`token`值。

`yyparse`: 语法分析，按照规则执行。

`yylex`: 词法分析，将字符语句转为一个个token。  我们需要手动写yylex, 常常是.l 文件 （flex/lex文件）

### .l 词法文件

```c
%{
Declarations
%}
%%
Productions	//	 规则
%%
User subroutines
```

例子：

```c
// cal.l
%{
#include "y.tab.h"   // 需要包含 Yacc 生成的 token 定义
%}

%%
[0-9]+	{ yylval = atoi(yytext); return T_Int; }	// 识别到一个T_Int token
[-+*/\n] { return yytext[0]; }
.       { /* ignore everything else */ }
%%
```

规则：  正则表达式-动作

`yytext`: 全局字符串。存放刚提供的字符串。

### 构建

```makefile
calc: lex.yy.o y.tab.o
		gcc -o calc lex.yy.o y.tab.o -ll
lex.yy.c: calc.l y.tab.c
	flex calc.l
y.tab.c: calc.y
	bison -vdty calc.y
```

`calc.y` =>  `y.tab.c` `y.tab.h`

`calc.l` => `lex.yy.c`

`bison` 生成语法分析。`flex` 生成词法分析。

### 执行示例：

`1 2 + 4 *`

语法分析是按照需要，调用`yylex`获取token。而不是一次性生成全部token流

Bbison 内部有一个语法栈，存储token和左边符号E（非终结符）。语法栈存的是符号E和语义值

| step | token     | rule                                   | bison stack（AST） | user action |
| ---- | --------- | -------------------------------------- | ------------------ | ----------- |
| 1    | `1 T_Int` | `E : T_Int { Push(yylval); }`          | `[E]`              | `[1]`       |
| 2    | `2 T_Int` | `E : T_Int { Push(yylval); }`          | `[E, E]`           | `[2]`       |
| 3    | `+`       | `E : E E '+' { Push(Pop() + Pop()); }` | `[E]` 匹配规约     | `[3]`       |

**bison识别表达式，AST/计算栈由user action完成。**

sqlite的lemon parser，user action：生成AST和BYTECODE



## bison-细节

只有需要带值时候，才要类型 ival或者sval。比如 $获取

[Declarations](https://www.gnu.org/software/bison/manual/html_node/Declarations.html)

1. 终结符：`%token <ival> T_INT ` , `%token T_PLUS T_MINUS`,`

2. 非终结符：`%type <ival> expr term factor`, `%type expr`
3. 语义值：`%union`

```yacc
%union{
	int ival;
	char* sval;
}
```

这个表示yylval联合，即我们扫描flex扫描到token，把各种类型值放入yylval. 

在声明token时候，可以指定类型，useraction 可以通过yylval.ival获取

4. 运算优先级

   ```YACC
   %left '+' '-'
   %right UMINUS
   ```

5. 入口、错误、调试

   ```
   stmt : expr ';'
   	| error ';' {yyerrok;}
   ```

   解析错误时候，会跳到error内置token，yyerrok表示错误已经处理好了，continue



### yyerror

yyerror参数默认就是 syntax error. 需要具体细节

```
extern int yylineno;  /* Flex 提供的行号 */
extern char *yytext;  /* 当前出错 token 文本 */

int yyerror(const char *s) {
    fprintf(stderr, "Syntax error at line %d: %s near '%s'\n", 
            yylineno, s, yytext);
    return 0;
}

```







## 编译器介绍

编译器几个阶段：

（词法分析+语法分析+语义分析+中间代码优化）+ 链接gcc 生成可执行文件。

Bison就是把语法/词法文件翻译成c代码。或许就是yacc名字来源。

sqlite

## Links

[bison_demo](https://github.com/ddongzi/CCODE/tree/main/bison_demo)

[sqlite bytecode 中文](https://cloud.tencent.com.cn/developer/section/1420079)

[flex & bison](http://home.ustc.edu.cn/~guoxing/ebooks/flex%E4%B8%8Ebison%E4%B8%AD%E6%96%87%E7%89%88.pdf)

## SQLite-Lemon

sqlite每条指令有一个opcode和P1～p5操作数

```shell
$ sqlite3 ex1.db
sqlite> explain delete from tbl1 where two<20;
addr  opcode         p1    p2    p3    p4             p5  comment      
----  -------------  ----  ----  ----  -------------  --  -------------
0     Init           0     12    0                    00  Start at 12  
1     Null           0     1     0                    00  r[1]=NULL    
2     OpenWrite      0     2     0     3              00  root=2 iDb=0; tbl1
3     Rewind         0     10    0                    00               
4       Column         0     1     2                    00  r[2]=tbl1.two
5       Ge             3     9     2     (BINARY)       51  if r[2]>=r[3] goto 9
6       Rowid          0     4     0                    00  r[4]=rowid   
7       Once           0     8     0                    00               
8       Delete         0     1     0     tbl1           02               
9     Next           0     4     0                    01               
10    Noop           0     0     0                    00               
11    Halt           0     0     0                    00               
12    Transaction    0     1     1     0              01  usesStmtJournal=0
13    TableLock      0     2     1     tbl1           00  iDb=0 root=2 write=1
14    Integer        20    3     0                    00  r[3]=20      
15    Goto           0     1     0                    00
```



## Orange-build my own

.l + .y + useraction

DELETE FROM tbl1 WHERE two < 20



终结符：词法分析产生的， 原子

非终结符;  语法分析组合的， 结构化表达式





### 正则表达式

`-?[0-9]+"."[0-9]*`

`-?`：0次或1次

`"."`：实际的.

`cat|dog`

`'[^']*'` 匹配任意不是'的符号

`SUBSTR(ING)?/"("    { return FSUBSTRING; }`

- `(ING)?` 表示可有可无。 SUBSTR, SUBSTRING
- `/"("` flex规则， 前瞻。 A/B，如果匹配A必须后面带着B，且B不会被消费。

### flex 规范

`@[0-9a-z_.$]+ { yylval.strval = strdup(yytext + 1); return USERVAR; }`

- yytext是字符串指针， +1即表示后移一个



complier : translate source code but doesn't execute it.  such as : gcc, clang

interpreter : translate source code and execute immediately. such as : ruby

![image-20250929224938440](https://raw.githubusercontent.com/ddongzi/ddongzi.github.io/master/assets/images/image-20250929224938440.png)

