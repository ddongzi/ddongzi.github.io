https://docs.djangoproject.com/zh-hans/6.0/search/?q=receiver&category=



view 试图 是需要访问的，通过urlconfs、





试图view 必须返回 HTTPResponse





ImageField字段



topic-comment一对多关系。

comment持有topic外键。

topic.comment_set.all 默认获取其对应的comments



## django命令

python manage.py shell

python manage.py createsuperuser



迁移： 改变数据库结构不需要重新创建删除

1. 编辑models.py，改变模型
2. python manage.py makemigrations appname 为模型改变生成迁移文件
3. python manage.py migrate执行数据库迁移
4. 

## django 模型

### meta元数据

元数据：不是字段的东西，如排序选项、

```python
class Bog(models.Model)：
	name = models.CharField()
    class Meta:
        ordering = ['name']
```





## django request

request.POST 对应普通表单

request.FILES 对应含文件上传表单

request.body json数据

## django urls

https://docs.djangoproject.com/zh-hans/6.0/topics/http/urls/

## django模板

### 模板语法：

{% raw %}
```jinja2
{{ var }}

{% if %} {% for %}

{% extends %} {% block %}

{% static 'path' %} 加载静态css/js
```
{% endraw %}




### 模板继承

父亲：

```jinja2
{% block 区域名字%}
孩子填充，如果没有填充就是默认内容
{% endblock %}
```

孩子：

```jinja2
{% extends "父亲模板路径" %}
```





### 部署静态文件

#### 用户上传文件MEDIA 没有默认路径，需要自己配置

1. 在settings.py添加

```python
MEDIA_URL = '/media/'       # 浏览器访问 URL
MEDIA_ROOT = BASE_DIR / 'media'  # 文件存放实际路径
```

2. 在项目urls.py添加路径

```python
if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_RO
```

3. 指定上传路径，会自动在media下面

```python
avatar = models.ImageField(default='avatar.png', upload_to='avatars')
```

4. 使用路径

```python
<img src="/media/avatars/liman.jpg" />
```



#### 静态文件默认寻找static文件夹





## django 用户状态

https://docs.djangoproject.com/zh-hans/6.0/topics/auth/default/

用session来管理，配合默认的User

如何知道是否已经登录，是哪个user？

试图里：`request.user.is_authenticated`

模板里：`user.is_authenticated` 不需要手动传入





## django 路由

### 反向解析：给路由层url起别名. 

#### 普通路径

如 `path('login2', views.login, name='login')`

在views.py中，reverse进行反向解析：`redict(reverse('login'))` 就可以获取对应正确url:login2

在模板中，{% url 路由别名 %}反向解析：`href = "{% url ‘login’ %}"`

#### 正则路径

`re_path(r'^login/([0-9]{2})/$', views.login, name='login')`

在views.py中，`redict(reverse('路由别名', args=(符合正则匹配的参数,))) ` 或者`return redirect(reverse('topic', kwargs={'topic_id': topic_id}))`

在模板，`{% url '路由别名' '符合正则匹配参数' %}`: `action = "{% url 'login' 10 %}"`



### 命名空间

当不同app拥有同一个路径别名时候，可能发生错误。

定义命名空间: include((app名字.urls, app名字))

`path('app01', include(('app01.urls'， 'app01')))`

`path('app02', include(('app02.urls'， 'app02')))`

后续通过,appname:路由别名，表示

reverse('app1:login')

```jinja2
{% url 'app1:login' %}
```





## django信号

内置信号：

- pre_save, post_save 分别在model.save前后发出。
- request_finished

### 监听信号

信号连接到接收器：

方法1：

```python
request_finished.connect(my_callback)
```

方法2：为其添加receiver装饰器

```python
@receiver(request_finished)
def my_callback(sender, **kwargs):
	print("Signal received");
```

一般的，我们将接收器都放在signals.py中，并在app ready时候注册



#### 关心 特定发送者的信号

比如，我们只关心MyModel这个发送出的pre_save

```python
@receiver(pre_save, sender = MyModel)
def my_callback(sender, **kwargs):
	print("Signal received");
```

#### 防止 重复接收信号



### 自定义 发送信号

定义：` pizza_done = django.dispatch.signal()`

发送信号：

`pizza_done.send(sender=PizzaStore, toppings = toppings, size = size)`

断开信号：取消接收器注册

`pizza_done.disconnect(receiver=Person)`



### 例子：

注册用户后自动创建profile.

注意到接收器是把一部分 send关键字参数拿出来了

```python
@receiver(post_save, sender=user)
def create_user_profile(sender, instance, created, **kwargs):
	if created:
		Profile.objects.create(user=instance)
```



## django CSRF

https://docs.djangoproject.com/zh-hans/6.0/howto/csrf/

表单中：

`<form > {% csrf_token %}`

js请求：

方法1：查找cookie

方法2：我们可以设置一个

`<meta name="csrf-token" content="{{ csrf_token }}">`

请求时候

```js
const csrftoken = document.querySelector('meta[name="csrf-token"]').content;
fetch(url, {
    method: 'POST',
    headers: {'X-CSRFToken': csrftoken}
});

```



## django notifications

https://github.com/django-notifications/django-notifications

2年不维护了，不能使用



## django messages



## django ORM

```python
class Notification(models.Model):
	actor = models.ForeignKey(User, on_delete=models.CASCADE)
    recipient = models.ForeignKey(User, on_delete=models.CASCADE)
```

由于user要做反向，User为actor生成反向属性，User.notification_set. 同理为recipent也生成了同样反向属性，这回冲突。

我们需要重命名他



### 关联关系：

一对多：



多对多：



ORM模型边界

外键的原因，默认拥有过多不必要的信息，需要。 但其实没事



## django admin

admin是全局的，但最好在每个应用中注册自己的



## django context processor

比如layout.html, 涉及未读通知，站点名称等全局变量，

### 内置

django内置了一些全局处理器

```json
'context_processors': [
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
```

### 自定义

通常会把处理器函数放在context_processors.py中

函数说明：

1. 参数必须有request
2. 返回值是字典
3. 在settings.py定义

```PYTHON
def global_site_name(request):
​	return {'site_name': settings.SITE_NAME}
```



## django 内置视图

https://docs.djangoproject.com/zh-hans/6.0/ref/views/#module-django.views



## django 内置过滤器

https://docs.djangoproject.com/zh-hans/6.0/ref/templates/builtins/#built-in-filter-reference

处理模板数据，加工、转换、过滤

### time

```django
{{ value|time:"TIME_FORMAT" }}
```

### timesince

`{{update | timesince }}`



## django 装饰器

内置装饰器

`@property`

## django 前端xss注入

safe字段： {{content | safe}} 就是渲染html。 {{content}} 就是字符串

显然加了safe特别不安全。

但是如果有些情况必须要渲染html，比如tinymce，那就必须在后端把html 清洗干净！！





## django 表单

https://docs.djangoproject.com/zh-hans/6.0/topics/forms/

django forms帮助我们方便处理form。

需要定义一个Form子类  应谁 到对应 前端某个表单。

提供：验证，model对应



### Form类

ModelForm 在表单直接编辑Model时候更好使用。

https://pythondjango.cn/django/basics/15-upload-files/#%E4%BD%BF%E7%94%A8modelform%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6



```python
profile = UserProfile.objects.get(id=user_id)
form = ProfileForm(request.POST, instance=profile)
if form.is_valid():
    form.save()
```

form.save(commit=false) 不会存到数据库而是返回对象，可以对对象继续修改

如果form中没有设置model的必要字段，严重不会通过的，比如user不需要更新，就需要save之后自己设置

```
obj = form.save(commit=false) 
obj.user = user
obj.save()
```

文件上传，必须是multipart-form type



## django 文件存储

https://docs.djangoproject.com/zh-hans/5.2/ref/files/storage/#:~:text=default_storage

### 默认存储类

存储实例：

默认的有FileSystemStorage，StaticFilesStorage。

defaultStorage对象为 配置中default

```python
from django.core.files.storage import storages
storages.backends
```

为MEDIA_ROOT 设置的
