# 基础语法

## 1. Python的可变数据类型和不可变数据类型？

可变不可变指的是内存中的值是否可以被改变  
可变数据类型有列表、字典和集合；不可变数据类型有整数、浮点数、字符串、元组和布尔值。  
可变对象可以在原来地址上修改元素，不可变则不行(即不能在自己身上增删改)，若要修改可以使用对象拼接赋值给新的对象，总之不能修改自身  



## 2. Python的内置数据结构？   

列表，集合，元组，字典      
list：有序可修改。通过索引进行查找、切片。使用方括号[ ]表示；
tuple：有序不可修改。可查询、切片操作。元组将多样的对象集合到一起，通过索引进行查找。用小括号（ ）表示；   
set：集合，无序可修改，无重复，无索引，不能跟列表一样切片。自动去重。使用set（[ ]）表示；   
dict：字典是一组key-value，通过key查找，无顺序，用{ }表示。

## 3. 字符串


### 3.1 操作


```python
s = 'hello'
print(s[::-1]) # 方法1：切片器
''.join(reversed(s)) #  方法2：其中reversed返回迭代器对象 
```

### 3.2 str用处

**1. Python 原生 `str` 对象**
在 Python 中，`str` 是一种 **不可变（immutable）** 的序列类型：

```python
text = "Hello, World!"
print(type(text))  # <class 'str'>
```

**常见的 `str` 方法：**

```python
text.lower()       # 'hello, world!'
text.upper()       # 'HELLO, WORLD!'
text.replace("World", "Python")  # 'Hello, Python!'
text.split(", ")   # ['Hello', 'World!']
```


**2. Pandas 的 `.str` 访问器**
在 **Pandas** 中，`Series` 里的 **每个元素** 都是 `str`，但不能直接用 Python 原生 `str` 方法，而是要用 **`.str` 访问器**：

```python
import pandas as pd
df = pd.DataFrame({'col': ['apple', 'banana', 'cherry']})

# 错误 ❌（直接调用 str 方法）
df['col'].upper()  # AttributeError: 'Series' object has no attribute 'upper'

# 正确 ✅（使用 .str 访问器）
df['col'].str.upper()
```

Pandas 的 `.str` 访问器 **批量应用** `str` 方法，相当于对 **Series 里的每个元素** 调用 Python 原生 `str` 方法。


总结：

| 环境            | 使用方式              |
| --------------- | --------------------- |
| Python `str`    | 直接用 `text.upper()` |
| Pandas `Series` | 用 `.str.upper()`     |

---

## 3.3 格式化字符串

- f：字符串插值，格式化输出
- r: 原始字符串,不会对\转义，用于正则、路径
- b: 字节字符串，用于二进制数据


```python
name = "Alice"
age = 25
print(f"My name is {name} and I am {age:.2f} years old.")
```


```python
print(r"C:\Users\Alice\Documents\new_file.txt")
```


```python
byte_data = b"hello"
print(byte_data)  
# 输出: b'hello'

print(byte_data[0])  
# 输出: 104 （'h' 的 ASCII 值）

# 转换回普通字符串
print(byte_data.decode("utf-8"))  
# 输出: hello

```

## 4. 最大最小数值、特殊值

整数：无最大最小限制，sys.maxsize 给出系统相关的参考值。超出后会自动处理，**不会溢出**  
浮点数：最大值约 1.8e308，最小正值约 2.2e-308，用 sys.float_info 获取。超出后会表示为无穷！  


```python
import sys
print(sys.maxsize) # 整数最大值：2^63-1
print(-sys.maxsize-1) # 整数最小值
print(sys.float_info.max) # 浮点最大值
print(sys.float_info.min) # 浮点最小值
# 特殊值
print(float('inf'))  # 无穷大
print(float('-inf')) # 负无穷大
print(float('nan'))  # 非数字
```

## 5. 列表

- sorted() vs. sort()
- extend(iterable): 将可迭代对象中的元素添加到列表的末尾。   

### 5.1 排序


```python
lines = ["banana", "apple", "cherry"]
lines = sorted(lines)  # 返回排序后的新列表，不修改原列表
# lines.sort()  # 原地排序，修改原列表
print("Sorted lines:", lines)

words = ['hello', 'world', 'big']
words.reverse()  # 原地翻转，修改 words 本身
print("Reversed words:", words)
```

### 5.2 增：append, extend


```python
ls = []  
path = ["folder", "subfolder", "file.txt"]
ls.append(path[:])  # 追加 path 的拷贝，后续修改 path 不影响 ls
path[2] = 'file1.txt'
print(ls)

ls1 = []
path = ["folder", "subfolder", "file.txt"]
ls1.append(path)  # 直接追加 path，后续修改 path 会影响 ls 中的值
path[2] = 'file2.txt'
print(ls1)
```


```python
lst = []
path = ["folder", "subfolder", "file.txt"]
lst.extend(path) # 追加的是拷贝，不影响后续修改。 等同于append(path[:])
path[2] = 'file3.txt'
print(lst)
```

### 5.3 去重

- 列表不可哈希，所以作为数组元素，**所以不能放入set**，得先把元素转为元组， 元组可以hash


```python
ls = [1, 2, 3, 2]
print(list(set(ls)))

# 元素为列表 去重
ls = [[1,2], [1,2]]
set([tuple(l) for l in ls])
```

## 6. del 删除

删除的是变量 （是引用）（指针）


```python
a = [1, 2, 3]
b = a
del a
print(b)

a = [0, 2, 2, 3]
a.remove(2)	# remove只是列表的一个方法
print(a)  # 输出 [0, 2, 3]
```

## 7. 字符串


```python
s = " hello world. "
s.strip() # 去除字符串首尾的空白字符
t = ['hello', 'world']
s=' '.join(t)
s.replace('  ',' ')		
ls=s.split()	# 将字符串分割为单词列表
```

## 8. 真假判断

### 8.1 假情况

False、None、空字符串""、数字0、空列表[\]、空字典{}或空元组()  



```python
stack = None
if not stack: #当stack为NOne  
    print('假')
```

### 8.2 is和== 的区别

is判断两个对象的内存地址是否相同, == 判断两个对象的值是否相同


```python
a1 = 'a'
a2 = 'a'
a1 is a2
a1 == a2
```

### 8.3 python , numpy, pandas 逻辑运算比较

**1. Python 原生逻辑运算**

| 逻辑运算     | 关键字 | 示例                       | 适用对象                | 是否支持向量化 |
| ------------ | ------ | -------------------------- | ----------------------- | -------------- |
| **与 (AND)** | `and`  | `True and False` → `False` | **单个布尔值** (`bool`) | ❌ 不支持       |
| **或 (OR)**  | `or`   | `True or False` → `True`   | **单个布尔值** (`bool`) | ❌ 不支持       |
| **非 (NOT)** | `not`  | `not True` → `False`       | **单个布尔值** (`bool`) | ❌ 不支持       |

✅ **适用于**：控制流（`if` 语句、`while` 循环）

⚠️ **不要用于**：NumPy 数组和 Pandas Series，会报错！

---

**2. NumPy 逻辑运算**

| 逻辑运算     | 关键字 | 示例                     | 适用对象                   | 是否支持向量化 |
| ------------ | ------ | ------------------------ | -------------------------- | -------------- |
| **与 (AND)** | `&`    | `(arr > 5) & (arr < 10)` | **NumPy 数组** (`ndarray`) | ✅ 支持         |
| **或 (OR)**  | \|     | `(arr < 3) \| (arr > 8)` | **NumPy 数组** (`ndarray`) | ✅ 支持         |
| **非 (NOT)** | `~`    | `~(arr > 5)`             | **NumPy 数组** (`ndarray`) | ✅ 支持         |

✅ **适用于**：数组计算，数学运算，矩阵操作

⚠️ **括号必须加，否则优先级错误**

---

**3. Pandas 逻辑运算**

| 逻辑运算     | 关键字 | 示例                             | 适用对象                     | 是否支持向量化 |
| ------------ | ------ | -------------------------------- | ---------------------------- | -------------- |
| **与 (AND)** | `&`    | `(df['A'] > 5) & (df['B'] < 10)` | **Pandas Series, DataFrame** | ✅ 支持         |
| **或 (OR)**  | `|`    | `(df['A'] < 3) | (df['B'] > 8)`  | **Pandas Series, DataFrame** | ✅ 支持         |
| **非 (NOT)** | `~`    | `~(df['A'] > 5)`                 | **Pandas Series, DataFrame** | ✅ 支持         |

✅ **适用于**：数据筛选、条件查询

⚠️ **不要用 `and` / `or`，必须用 `&` / `|` 并加括号**

---

**结论 & 实际建议**

| 适用场景                                | 推荐使用                         |
| --------------------------------------- | -------------------------------- |
| **控制流 (`if`, `while`)**              | Python 关键字 `and`, `or`, `not` |
| **NumPy 数组 (ndarray) 计算**           | `&`, `|`, `~` 并加括号           |
| **Pandas 数据筛选 (DataFrame, Series)** | `&`, `|`, `~` 并加括号           |

**最佳实践**

- **Python 控制流**

  ```python
  if x > 5 and y < 10:
      print("Valid")
  ```

- **NumPy 数组运算**

  ```python
  import numpy as np
  arr = np.array([1, 6, 8])
  result = arr[(arr > 5) & (arr < 10)]  # ✅ 正确
  ```

- **Pandas 数据筛选**

  ```python
  import pandas as pd
  df = pd.DataFrame({'A': [1, 6, 8], 'B': [3, 9, 2]})
  result = df[(df['A'] > 5) & (df['B'] < 10)]  # ✅ 正确
  ```

**⚡ 记住：**

1. `and` / `or` / `not` 只适用于**单个布尔值**。

2. **NumPy 和 Pandas 必须用 `&` / `|` / `~`，并加括号**。

3. **数据筛选建议用 `.loc[]` 提高可读性**：

   ```python
   df.loc[(df['A'] > 5) & (df['B'] < 10)]
   ```

掌握这些，就能写出高效、正确的 Python 逻辑运算！ 🚀

---

## 9. 可迭代对象iterable

就是可以逐个返回元素的可以 用for的

list、tuple、str、set、dict、range、文件对象、迭代器、生成器


```python

```

## 10. 字典

### 10.1 键

字典的*键必须是不可变*的类型。不可以使用列表作为键。字典键的常见类型包括整数、浮点数、字符串、元组等不可变类型。  


```python
my_dict = {1: 'one', 2: 'two', 3: 'three'} # 键为整数
another_dict = {'apple': 3, 'banana': 5, 'orange': 2} # 键为字符串
yet_another_dict = {(1, 2): 'tuple_key', (3, 4): 'another_tuple_key'} # 键为元组
my_dict = {('John', 25): 'value1', ('Alice', 30): 'value2'} # 键位元组
```

### 10.2 根据key排序: `sorted()`

在`sorted()`函数中指定要排序的元组列表和一个函数，可以是lambda，参数是item 
`sorted()`返回排序好的元组列表


```python
my_dict = {'apple': 10, 'orange': 5, 'banana': 20, 'grape': 7}
print(my_dict.items()) # 元组列表

s = sorted(my_dict.items(), key = lambda x: x[0]) # 排序元组列表
print(s)

sorted_dict = dict(s) # 元组列表转为字典
print(sorted_dict)

# key函数
def get_key(item):
    return item[0]

```

## 11. 推导

可以从一个数据序列构建另一个新的数据序列的结构体。 常见 从列表 推到 字典等


```python
names = ['Bob','Tom','alice','Jerry','Wendy','Smith']

# 列表推导式
new=[ name.upper() for name in names]
multiples = [i for i in range(30) if i % 3== 0] # 3 的倍数
print(multiples)
#字典推导式
dic={name:len(name) for name in names}
print(dic)
# 集合推导式
sett={name.upper() for name in names}
print(sett)
# 元组推导式
tt = tuple(name.lower() for name in names)
print(tt)  # ('alice', 'bob', 'charlie')


```

> !! 这个不是元组推导， 这个是生成器表达式。 可以通过遍历、转换才能看到内容。 且只能用一次


```python
tt = (name.lower() for name in names)
print(tt)  # ('alice', 'bob', 'charlie')
print(list(tt))

print(set(tt))
print(tuple(tt))

```

## 21. 循环



```python
for i in range(6):
    print(i)
    i += 1# 这一行对循环没有影响
```

## 13. 迭代器

迭代器是一个可以记住遍历位置的对象。  
通过迭代器返回当前元素。  
迭代器有两个基本的方法：iter() 和 next()。  
许多内置对象都是可迭代的，例如列表、元组、字符串等。  



```python
class MyIterator:
    def __init__(self,data):
        self.data=data
        self.index=0
    # 返回迭代器自身
    def __iter__(self):
        return self
    # 返回下一个元素
    def __next__(self):
        if self.index<len(self.data):
            result = self.data[self.index]
            self.index += 1
            return result
        else:
            raise StopIteration
my_list=[1,2,3,4]
my_custom_iterator = MyIterator(my_list)
for element in my_custom_iterator:
    print(element)
```

## 14. map(),filter(),reduce()

⚡对可迭代对象进行 转换、筛选、聚合

- `map()` & `filter()` **返回可迭代对象**（需 `list()` 解析）。  
- `reduce()` **返回单个值**，需手动 `import`。  
- **偏函数式编程**，适合数据处理（但 `map/filter` 可用列表推导式代替）


```python
# 数据转换
names = ['Alibba', 'Baudu', 'Conr']
print(map(lambda x:len(x),names))
lens=list(map(lambda x:len(x),names))
print(lens)

# 筛选
print(filter(lambda x:len(x)<5, names))
smalls = list(filter(lambda x:len(x)<5, names))
print(smalls)


```


```python
# reduce()
from functools import reduce
numbers = [1, 2, 3, 4]
product = reduce(lambda x, y: x * y, numbers)
print(product)  # 24（1*2*3*4）
```

## 15.遍历技巧


### 15.1. 字典遍历

字典中遍历时，关键字和对应的值可以使用 items() 方法同时解读出来：


```python
for k in {'a':1,'b':2} :
    print(k)
knights = {'gallahad': 'the pure', 'robin': 'the brave'}
for k,v in knights.items():
    print(k,v)
```

### 15.2 序列遍历

- 序列中遍历时，索引位置和对应值可以使用 enumerate() 函数同时得到.  
- 同时遍历两个或更多的序列，可以使用 zip() 组合:


```python
names = ['apple', 'con', 'ele']
for i, name in enumerate(names):
    print(i, name)
```


```python
for f in sorted(set(names)): # 有序遍历
    print(f)
```


```python
questions = ['name', 'quest', 'favorite color']
answers = ['lancelot', 'the holy grail', 'blue']
for q, a in zip(questions, answers):
    print(q, a)
```

## 16. 输入输出



### 16.1. 文件读写


```python
f=open('temp.txt','w')
f.write(' python open file \n nandwnowdoi')
f.close()

f=open('temp.txt','r')
l = f.read() # 按字符串。
ls=f.readlines() # 按行数组
print(ls)
```

## 18. 拷贝：

主要**针对复杂对象（例如嵌套的列表或字典）中的子对象**的复制方式而言。  


```python
persons = [{'name': 'john', 'age':11}, {'name': 'trump', 'age':22}]
pcopy = persons.copy()
pcopy[1]['age'] = 33
print(persons)
print(pcopy) # 操作的是指针引用， 所以修改一致。
```


```python
import copy
lst = [[1, 2], [3, 4]]
deep_lst = copy.deepcopy(lst)  # 正确做法
deep_lst[1][0] = 3333
print(deep_lst)
print(lst)
```

## 19.集合



```python
x = 99
s = set()
s.add(x)
s.remove( x )
s.clear()
```

## 20. 生成器

生成器（Generator）是一种**特殊的迭代器**，它允许按需生成值，  
生成器使用 yield 关键字来**实现暂停和恢复执行**，允许函数在每次产生值后暂停并在下一次调用时继续执行。  
定义生成器：  

- 生成器函数:使用 yield 关键字的函数。
- **生成器表达式** : 类似于列表推导式，但使用圆括号。  

yield和return：  

- 相同点：都是返回程序的执行结果；
- 区别：yield返回结果但程序还没有结束，return返回结果表示程序已经结束执行


```python
# 方法1：生成器函数
def my_generator():
    yield 1
    yield 2
    yield 3
gen = my_generator()
print(next(gen))  # 输出: 1
print(next(gen))  # 输出: 2
print(next(gen))  # 输出: 3

# 方法2：生成器表达式
gen = (x for x in range(1, 4))
print(next(gen))  # 输出: 1
print(next(gen))  # 输出: 2
print(next(gen))  # 输出: 3
```

## 22. 不定⻓参数

在不确定需要传多少参数时使用，args表示位置参数，元组形式保存，kwargs表示关键字参数


```python
def cache(func):
    # 缓存计算结果的字典
    cached_results = {}
    
    # 装饰器的包装函数
    def wrapper(*args, **kwargs):
        # 使用输入参数构建唯一的键
        key = (args, tuple(kwargs.items()))
        
        # 如果缓存中不存在对应键的结果
        if key not in cached_results:
            print('不在缓存中')
            # 调用被装饰的函数，并将结果缓存起来
            cached_results[key] = func(*args, **kwargs)
        
        # 返回缓存中的结果
        return cached_results[key]
    
    # 返回装饰后的函数
    return wrapper
@cache
def add(x, y):
    print("Calculating result...")
    return x + y

result1 = add(2, 3)  # 计算并缓存结果
result2 = add(2, 3)  # 直接从缓存中获取结果，不再计算
result3 = add(4, 5)  # 计算并缓存新的结果

print(result1)  # 输出: 5
print(result2)  # 输出: 5
print(result3)  # 输出: 9
```

## 24. with

- with 语句用于对文件、网络连接、线程锁等资源进行管理.  
- with原理：跟着上下文。


```python
class MyContext:
    def __enter__(self):
        print("进入上下文")
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        print("退出上下文")

with MyContext():
    print("执行代码块")

```

### 24.1. 文件

- 异常时候自动关闭
- with块外自动关闭文件


```python
with open('test.log', 'r') as f:
    f.read()
# f.read() 此时已经关闭了
```


```python
import os
os.makedirs('hellodir')
with open('hellodir', 'r') as f:
    f.read()
```

### 24.2. 线程锁子

- with块内线程安全
- 离开后自动释放


```python
import threading
lock = threading.Lock()

with lock:  # 自动上锁 & 释放
    print("线程安全操作")
```

### 24.3. 数据库


```python
import sqlite3
with sqlite3.connect("database.db") as conn:
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM users")
    result = cursor.fetchall()
# 离开 `with` 块，连接 **自动提交 & 关闭**
```

## 25. 异常处理


```python
try:
    x = 1 / 0 # 触发 ZeroDivisionError
except ZeroDivisionError:
    print("除数不能为 0")  # 处理异常
else:
    print("计算成功:", result)  # 只有 try 代码成功执行，才会进入 else
finally: # 资源释放
    print("无论是否异常，都会执行")  
```

### 25.2. 捕获多个异常


```python
try:
    num = int("abc")  # ValueError
except (ZeroDivisionError, ValueError) as e:
    print(f"发生错误: {e}")  # 统一处理

```

### 25.3 自定义异常


```python
class MyError(Exception):
    pass
try:
    raise MyError('自定义错误')
except MyError as e:
    print(f"捕获异常: {e}")

```


```python

```

## 26 数字

1. python数值中的下划线只是增强可读性


```python
a = 100_000  # 等价于 100000
b = 1_234_567  # 等价于 1234567
c = 0b1010_0101  # 二进制 10100101，等价于 165
d=5e-3
```


```python

```

## 27 range对象

- 内置的不可变序列, 用于生成等差序列
- 可以索引切片
- 不是列表
- 高效，惰性计算，需要时候才加载内存


```python
type(range(5))
```


```python
range(5)[:1]
```


```python
import sys
big = range(10**9)
sys.getsizeof(big) # 并不是全部内存
```


```python

```

## 30. np.sum vs. sum


```python
import numpy as np
help(np.sum)
help(sum)
```

---

## 31. 解包*



```python
import numpy as np
data = np.random.randn(3,4)
data += np.random.randn(*data.shape)
```

## 32. 内置函数


```python
# 查看对象的属性和方法
# 查看模块的函数常用
dir()
```


```python
import os
dir(os)
```

# 常用模块

## 1. logging

相比 print()，logging 更灵活，支持 日志级别（INFO、ERROR 等）、日志格式化、写入文件、多线程安全，适用于生产环境的日志管理。


```python
import logging

logging.basicConfig(filename="test.log",level=logging.INFO)
logging.debug('debug message')
logging.info("info message")
logging.warning('warn message')
logging.error("error message")
logging.critical('critical message')
```

## 2. os


```python
import os
```

### 2.1. 文件/目录


```python
import os
os.makedirs("test_dir", exist_ok=True)  # 创建目录, 
#os.remove("test.log")  # 删除文件
os.rmdir("test_dir")  # 删除空目录
print(os.getcwd())  # 获取当前工作目录
os.path.join("dir", "file.txt")  # 拼接路径，跨平台适配
```


```python
# 递归遍历
for root,dirs,files in os.walk(os.getcwd()):
    print(root, dirs, files,'\n') # 当前root有哪些目录，文件
    for f in files:
        full_path = os.path.join(root, f)

```


```python
help(os.makedirs)
```

### 2.2. 环境变量


```python
print(os.getenv("PATH"))  # 获取环境变量
os.environ["MY_VAR"] = "value"  # 设置环境变量
os.environ.pop("MY_VAR", None) # 删除环境变量
```

### 2.3. 执行系统命令


```python
os.system("ls")  # 运行 shell 命令（不推荐，安全性低）
```

### 2.4. 进程控制


```python
os.getpid()  # 获取当前进程 ID
#os.fork()  # 创建子进程（仅 Unix）
```




    12360



## 3. sys

提供与 Python 解释器和系统交互的功能，如 命令行参数、标准输入输出、解释器信息、退出程序 等。

### 3.1. 命令行参数 


```python
import sys
print(sys.argv)  # 当前程序命令行参数
```

### 3.2. 程序退出


```python
sys.exit(0)  # 0 表示正常退出，非 0 表示异常
```

### 3.3. 标准输入输出


```python
sys.stdout.write("Hello\n")  # 标准输出
sys.stderr.write("Error message\n")  # 标准错误
```

### 3.4. 解释器信息


```python
print(sys.version)  # Python 版本
print(sys.platform)  # 当前操作系统
```

## 3. shutil

简化的文件操作模块，提供了 文件和目录的复制、移动、删除 等功能，常用于 文件管理和批量操作。

### 3.1. 复制


```python
import shutil
shutil.copy("source.txt", "destination.txt")  # 复制文件
shutil.copy2("source.txt", "destination.txt")  # 复制文件并保留元数据
```


```python
import shutil
shutil.copytree("source_dir", "destination_dir")  # 复制整个目录及其内容
```

### 3.2. 移动文件或目录


```python
import shutil
shutil.move("source.txt", "destination.txt")  # 移动文件或目录
```

### 3.3. 压缩


```python
shutil.make_archive("archive", "zip", "directory_path")  # 创建压缩包
shutil.unpack_archive("archive.zip", "destination_dir")  # 解压文件
```

## 4. glob文件查找

glob 模块用于 查找匹配指定模式的文件路径，支持 通配符（如 *、?、[]），常用于 文件路径匹配和批量操作。

### 4.1. 查找匹配的文件：


```python
import glob
files = glob.glob("*.txt")  # 查找当前目录下所有的 .txt 文件
print(files)  
files = glob.glob("./*")  # 查找 'dir' 目录下的所有文件和目录
print(files)
```

### 4.2. 递归查找


```python
files = glob.glob("**/*.txt", recursive=True)  # 查找所有子目录中的 .txt 文件
print(files)
```

## 5. re

`re` 模块是 Python 的 **正则表达式模块**，用于处理 **字符串模式匹配**，支持 **查找、替换、分割** 等操作，广泛应用于文本处理和数据清洗。

### 5.1. 匹配


```python
import re
pattern = r"\d+"
match = re.match(pattern, "123abc") # 从头匹配
print(match.group())

text = "Hello 123, world 456"
match = re.search(r"\d+", text) # 任意开始匹配 一个
print(match.group())  # 123

text = "The price is 100 dollars and 200 yen."
matches = re.findall(r"\d+", text) # 任意开始匹配 多个
print(matches)
```

### 5.2. 替换


```python
text = "I have 100 apples. 200 bars."
result = re.sub(r"\d+", "many", text) # 替换匹配（findall)
print(result)
```

### 5.3. 分割


```python
text = "apple,orange;banana grape"
result = re.split(r"[,; ]", text)  # 按逗号、分号和空格分割
print(result)

```

## 6. math



```python
import math
print(math.sqrt(16))   # 4.0，平方根
print(math.ceil(4.2))  # 5，向上取整
print(math.floor(4.8)) # 4，向下取整
print(math.fabs(-5))   # 5.0，绝对值
print(math.factorial(5)) # 120，阶乘

print(math.pow(2, 3))    # 8.0，2^3
print(math.exp(1))       # e^1
print(math.log(8, 2))    # 3.0，以 2 为底的对数
print(math.log10(100))   # 2.0，以 10 为底的对数

print(math.sin(math.radians(30)))  # 0.5
print(math.cos(math.radians(60)))  # 0.5
print(math.tan(math.radians(45)))  # 1.0

print(math.pi)   # 3.141592653589793
print(math.e)    # 2.718281828459045

```

## 6. random

### 6.1. 随机数生成


```python
import random
random.seed(42)  # 设置种子，确保随机数可复现
print(random.random())  # 生成 0~1 之间的随机浮点数
print(random.randint(1, 10))  # 生成 1~10 之间的随机整数（包含 10）
print(random.uniform(1, 5))  # 生成 1~5 之间的随机浮点数
```

### 6.2. 随机选择


```python
items = ['apple', 'banana', 'cherry']
print(random.choice(items))
print(random.choices(items, k=2)) # 随机选择 2 个元素（可重复）
print(random.sample(items, 2))  # 随机选择 2 个不同元素
```

### 6.3. 打乱


```python
numbers = [1, 2, 3, 4, 5]
random.shuffle(numbers)  # 原地打乱顺序
print(numbers)
```

## 7. datetime, time

- `datetime`：处理日期和时间，如 **获取当前时间、格式化、计算时间差**。  
- `time`：处理 **时间戳、延时、CPU 计时**，更底层。 

### 7.1. 获取当前日期时间


```python
from datetime import datetime
now = datetime.now()
print(now)
datetime.date()
```

### 7.2. 自定义日期


```python
from datetime import datetime
from datetime import date
dt = datetime(2025, 3, 6, 14, 39)
print(dt)
dt = date(year = 2025, month=1,day=1) # 日期
dt

```

### 7.3. 格式化日期


```python
print(now.strftime("%Y-%m-%d %H:%M:%S"))  # 2025-03-06 12:34:56
```

### 7.4. 解析字符串为日期对象


```python
dt = datetime.strptime("2025-03-06 14:30", "%Y-%m-%d %H:%M") # 日期对象
dt
```

### 7.5. 计算时间差


```python
from datetime import timedelta
tomorrow = now + timedelta(days=1)
tomorrow
```

### 7.6. 获取时间戳


```python
import time
print(time.time())
```

### 7.7. sleep


```python
time.sleep(2)
```

### 7.8. 时间戳格式化


```python
print(time.strftime("%Y-%m-%d %H:%M:%S"))  # 自定义格式化
time.ctime(time.time()) # 正常格式化
```

## 8. zlib压缩


```python
import zlib
s=b'witch which has which witches wrist watch'
print(len(s))
t=zlib.compress(s)
print(len(t))
zlib.crc32(s)
```

## 9. json

### 9.1. 对象序列、反序列 json字符串


```python
import json
data = {"name": "Alice", "age": 25, "city": "New York"}
json_str = json.dumps(data)  # 转换为 JSON 字符串
print(json_str)  # '{"name": "Alice", "age": 25, "city": "New York"}'
print(json.dumps(data, indent=4))  # 生成格式化 JSON， 缩进换行

data = json.loads(json_str)  # 解析 JSON 字符串
print(data["name"])  # Alice
```

### 9.2. 对象序列、反序列 json文件


```python
import json
# 写入json文件
with open('data.json', 'w') as f:
    json.dump(data, f)

# 读取 JSON 文件
with open("data.json", "r") as f:
   data = json.load(f)

```

## 10. itertools迭代工具

适用大规模数据处理，排列组合、无限迭代

1. 排列组合


```python
import itertools
combinations = list(itertools.combinations([1,2,3],2))
print(combinations)  # [(1, 2), (1, 3), (2, 3)]

permutations = list(itertools.permutations([1, 2, 3], 2))
print(permutations)  
```


```python

```

2. 无限迭代


```python
# cycle无限循环
c = itertools.cycle(['a','b','c'])
for _ in range(5):
    print(next(c))
```


```python
# 无限递增
for i in itertools.count(start=10, step=2):
    print(i)
    if i>20:
        break
```


```python
# 重复元素
r = itertools.repeat('hello',3)
print(list(r))
```

---

# 多线程

GIL（全局解释器锁） 限制了 Python 线程的并行计算，适用于 I/O 密集型 而非 CPU 密集型 任务。

## 1. 线程创建、启动


```python
import threading
def task():
    print("线程执行中")
t = threading.Thread(target=task)  # 创建线程
t.start()  # 启动线程
t.join()  # 等待线程结束

```

## 2. Lock 线程锁


```python
lock = threading.Lock()
counter = 0

def safe_increment():
    global counter
    with lock:  # 自动上锁 & 释放
        counter += 1

t1 = threading.Thread(target=safe_increment)
t2 = threading.Thread(target=safe_increment)
t1.start(); 
t2.start()
t1.join();
t2.join()
print(counter)
```

## 3. ThreadPoolExecutor 线程池

更好的执行，


```python
from concurrent.futures import ThreadPoolExecutor
def task(n):
    return n*n

results = []
with ThreadPoolExecutor(max_workers=5) as executor:
    results = list(executor.map(task, range(5))) # executor.map方法，task执行5次，参数分别为后面的0,1,2,3,4
print(results)
```


```python

```

# 面向对象

Python **支持面向对象编程**（OOP），主要概念包括 **类（Class）、对象（Object）、封装、继承、多态**。  

变量命名空间和作用域



```python
def scope_test():
    def do_local():
        var = 'do local var'
    def do_nonlocal():
        nonlocal var
        var = 'do nonlocal var'

    def do_global():
        global var
        var = 'do global var'
    var = 'scope var'
    do_local()
    print('after do_Local : ', var) 
    do_nonlocal()
    print('after do_nonlocal : ', var)
    do_global()
    print('after do_global : ', var)

scope_test()
# print(var) # if we don't have global, name 'var' is not defined
print('In global scope : ', var)
```

注意的是：   nonlocal说明变量在外层作用域改变；global说明变量在模块层面改变

类


```python
class MYClass:
    """ 这是一个类
    """
    i = 1
    def f(self):
        return 'hello'
```


```python
print('类属性', MYClass.f, MYClass.i, MYClass.__doc__)
```



__init__ 初始化类对象


```python
class MYClass:
    counter = 1
    def f(self):
        pass
```


```python
x = MYClass()
print('对象属性:', x.counter, '\t', x.f)
print('类属性:', MYClass.counter, '\t', MYClass.f)
```

可以看到: 对于数据属性，类和对象等价。方法属性，两者却完全不同。但是 x.f() 等价于 MYClass.f(x)


```python
print('方法属性的对比！', '\n', x.f, '\n', MYClass.f, '\n',  MYClass.f(x))
```


```python

```

错误使用类属性和对象属性：


```python

```


```python
class Animal:
    tricks = [] # 数据类属性
    def __init__(self, name):
        self.name = name
    def t(self):
        self.tricks.append(self.name)
dog = Animal('dog')
dog.t()
cat = Animal('cat')
cat.t()
print(Animal.tricks, dog.tricks, cat.tricks)
```

对象属性和类属性冲突时候， 对象属性访问优先选择实例，且不影响类属性的。


```python
class Animal:
    name = 'animal'
dog = Animal()
print(dog.name)
dog.name = 'dog'
print(Animal.name, dog.name)
```

## 2. 封装

私有属性. 通过定义getter/setter控制访问。


```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.__age = age
    def get_age(self):
        return self.__age
p = Person("张三", 30)
print(p.get_age())  # 30
# print(p.__age)  # ❌ 报错，外部无法访问
```

## 3. 继承


```python
class Dog(Animal): # 继承
    def speak(self): # 重写父亲方法
        return f"{self.name} 汪汪！"
d = Dog("哈士奇")
print(d.speak())  # 哈士奇 汪汪叫
```

## 4. 多态


```python
class Cat(Animal):
    def speak(self):
        return f"{self.name} 喵喵！"
animals = [Dog("小狗"), Cat("小猫")]
for a in animals:
    print(a.speak()) # 提升为父类，  自动调用不同子类的重写方法。
```

## 5. super父类调用


```python
class Fly(Animal):
    def __init__(self, name, color):
        super().__init__(name) # 父亲构造
        self.color = color
```

❓__class__, __name__

# 面试题

1. 输入某年某月某日，判断这一天是这一年的第几天？


```python
import datetime
def dayofyear():
    year = input("year:")
    month = input("month:")
    day = input("day:")
    date1 = datetime.date(year = int(year), month = int(month), day = int(day))
    date2 = datetime.date(year = int(year), month = 1, day = 1)
    return (date1 - date2).days
dayofyear()
```

## 函数参数


```python
def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):
    pass
```


```python
def f(pos_arg, *v_turple_args,  default_arg = 'Hello', **v_dict_args,):
    """ 参数的三种调用情况：位置参数、关键字参数、使用默认参数
    
    """
    print(pos_arg, default_arg, v_turple_args, v_dict_args)
```


```python
f(1,  (1,2), {'name': 'dong'},default_arg= 'go')
```

默认值参数只计算一次，但是对于可变对象就不一样了。


```python
i = 5
def f(i = 5):
    return i
i = 6
print(f())
```


```python
def f(e, l = []):
    l.append(e)
    return l
print(f(1))
print(f(2))
print(f(3))
```

/ 和 * 参数限制


```python
def standard_arg(arg):
    print(arg)
def pos_only_arg(arg, /):
    print(arg)
def kwd_only_arg(*, arg):
    print(arg)
def combine_arg(pos_only, /, pos_or_kwd, *, kwd_only):
    print(pos_only, pos_or_kwd, kwd_only)
```


```python
standard_arg(1)
```


```python
standard_arg(arg = 1)
```


```python
pos_only_arg(1)
```


```python
pos_only_arg(arg = 1)
```


```python
kwd_only_arg(1)
```


```python
kwd_only_arg(arg=1)
```


```python
combine_arg(1, 2, kwd_only=3)
```


```python
combine_arg(1, pos_or_kwd=2, kwd_only= 3)
```

形参标注


```python
def f(i : int, s : str = 'eggs') -> str:
    print(i, s)
```


```python

```





# 高效python

## 1. bytes, str, unicode

