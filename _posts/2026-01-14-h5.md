# HTML

## 链接

[css实验案例](https://labs.jensimmons.com/)

## 

## display

https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference/Properties/display

支持多关键字语法，比如为一个button，`display:inline flex` 。也可以使用预组合

### 外部表现

block, inline 表现为块级/行级 盒子

### 内部表现

flow,table,flex,grid 内部布局

### 列表元素



### table内部元素



### none

元素不显示，不存在。 vs visibility

### 预组合

inline-block, inline-flex ..







## align-items

值需要依赖布局。

- normal:
- 

## 表单编码

 `application/x-www-form-urlencoded`

enctype="multipart/form-data"

## button,a,input作为按钮的区别：

- 提交数据：button, input
- 跳转页面：a
- 未知：button

`<button>` 支持submit/button/reset类型；内部可通过`<i>`放图标

- submit:提交表单数据
- button：没有默认行为
- reset：？

相比于`<button>, <input>`一般不使用。



## name,value属性

name作为名字，value作为值。

比如`<button name='action' value='login' type='submit'>` 提交时候会跟着表单， `action:login`



## CSS 值和单位

https://developer.mozilla.org/zh-CN/docs/Learn_web_development/Core/Styling_basics/Values_and_units

绝对长度：

印刷有用。

`1cm = 37.8px`

相对长度：

- em: 相对本元素的字体大小
- vh,vw：相对视窗

font-size单位/ line-height单位：

em: 字体大小是父亲的n倍。

rem: 字体大小是根的n倍。 

类似em,rem， 也可以表示行高，如用来创建记事本：

lh: 行高是父亲的N倍

rlh:行高是根的n倍



1rem = 根元素（html）的字体大小(font-size)。**常用**



百分比：

父亲元素的%



颜色：关键字。16紧致，rgb

一个颜色由红绿蓝三种程度组成， `256*256*256`

rgb可以提供第四个参数，表示颜色透明度。（opacity是让所有不透明)

`rgb(18 138 125 / .9)`

## vertical-align

对行级元素生效。

## font

100 → 极细
400 → normal（默认）
500 → medium
700 → bold

## css渐变

https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference/Values/gradient/repeating-linear-gradient

`repeating-linear-gradient()`函数： 重复线性渐变，在所有方向上渐变，覆盖所应用的元素。 本质上是一个`<image>`



## box-shadow

https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference/Properties/box-shadow



## data-*

[data-*](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Reference/Global_attributes/data-*)

https://developer.mozilla.org/zh-CN/docs/Web/HTML/How_to/Use_data_attributes





## CSS 伪类 

`:` 伪类。 不是HTML真实存在的，描述元素状态/结构

a:hover, input:focus, li:first-child



[] 属性选择器，根据属性选择元素

input[type='text'],button[disabled]

https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference/Selectors/Pseudo-classes

### 元素显示状态

*:open* 匹配具有打开/关闭状态的元素

*:fullscreen* 匹配处于全屏模式的元素

### 表单元素输入状态

*:enabled*

*:checked*

### 语言伪类

*:lang()*

### a连接状态

*:link* 还未访问

*:visited*

### 媒体资源状态

*:playing*

*:paused*

### 文档树结构

*:root* 根部html

*:empty* 除了空格字符没有其他子元素的

*:nth-child()*

*:first-child*

### 用户行为

*:hover* 用户悬停

*:active* 用户按下， 如 `<a>` `<button>` 点着

*:focus*





## CSS伪元素

::伪元素

::before, ::after

## css 变量

通常在:root根伪类下，定义. --命名

```css
:root {
	--main-bg-color: brown;
}
```

```css
element {
	background-color: var(--main-bg-color);
}
```

默认值

```css
element {
	background-color: var(--main-bg-color, red);
}
```



## 网格布局

[MDN grid](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Guides/Grid_layout/Common_grid_layouts)

基本使用，通过grid-area.

## textarea默认不遵守全局/父亲的 字体



## 样式设计

https://developer.mozilla.org/zh-CN/docs/Learn_web_development/Extensions/Forms/Styling_web_forms#%E8%A1%A8%E5%8D%95%E5%BE%AE%E4%BB%B6%E6%A0%B7%E5%BC%8F%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%8C%91%E6%88%98

### 微件样式：

#### 字体，文本

某些微件不会默认继承： font-family font-size， 如button,input，select, textarea

```css
button,
input,
select,
textarea {
  font-family: inherit;
  font-size: 100%;
}
```

不同浏览器表现也不太一样。



#### 盒子尺寸

每个微件都有自己默认的边框，内外边距等。 通过box-sizing: border-box。消除

比如文本字段，width,height,padding,margin,border

```css
input,
button {
 box-sizing: border-box;
    margin: 0;
    padding: 0;
}
```

#### 图例摆放

<img src="C:\Users\63517\Documents\notes\assets\image-20251216114147077.png" alt="image-20251216114147077" style="zoom: 33%;" />





## 标签

### cite, blockquote,q



### span, p 区别

span没有特殊意义，是一个行级元素。与div类似，但div是块级。



### h标题

要点：

- 如果需要减小标题字体大小，使用font-size。 不要降低标题等级。
- 不要跳过标题级别，从h1开始，h2,h3。。等等，不要断档

## white-space

页面默认会合并空格换行 为 一个空格

pre-line: 行内空格合并。 换行不变



## tinymce

[我的账号 |小云](https://www.tiny.cloud/my-account/subscription/)



## 组件实现

### 下拉菜单

https://www.runoob.com/css/css-dropdowns.html

## svg i

更倾向于前者，

svg用icon类

# CSS

https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference/Properties/box-sizing

## 内置

### 内置关键字

*currentColor* 使用当前元素的color值， 比如 border color : currentColor

### 内置函数

`light-dark(red, white)`

## box-sizing

css盒子模型默认 content-box. 这意味着width和height是对内容而言的，所加的border，padding都会在之外。

比如设置了 widtht : 100%. 再去设置边框和内边距，就会超出父亲边界

一般的，border-box更容易计算，内容就是 width-padding-border.

因此，

```css
* {
	box-sizing: border-box;
}
```

## hsl

*色相*、*饱和度*和*明度*表示颜色



## 选择

[属性]

.button[data-variant='primary']

a[data-url='']

img[src='']

```
  .button[data-variant=''][data-action=positive]:hover {
    background-color:light-dark(var(--color-green-20),var(--color-green-50))
  }
```



## 优先级

尽量不要使用!important	

# JS

## JS 获取内容

https://developer.mozilla.org/zh-CN/docs/Web/API/Node/textContent

innerHTML, innerText, textcontent 区别

- innerText只会获取人看得到的文本内容。textContent获取下面所有文本，包括script里面的。
- innerText在某些浏览器不可用
- textContent相比与innerHTML，可以防止XSS注入

## dom

### 获取dom

*getElementBy__('_')* : id 获取节点是唯一的， 标签和类名获取的是list

*querySelector('__')*: 统一查询，返回第一个

*.closest('__')* 

*.children*

### 创建dom

*document.createElement('div'）* 标签节点

*document.createTextNode('__')* 文本内容 节点

### dom属性

*.style.color*

*.classList*

*.dataset.*

*.href*

*.id*

*.attributes*

## IntersectionObserver

https://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html





## Promise

异步操作结果。

https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises

回调的写法，

一般是这样，通过参数传入。

`createAudioFileAsync(audioSettings, successCallback, failureCallback);` 

promise方式，`createAudioFileAsync`返回promise形式，通过then注册回调

`createAudioFileAsync(audioSettings).then(successCallback, failureCallback);`



then返回的也是promise



**回调地狱**

```js
doSomething(function (result) {
  doSomethingElse(result, function (newResult) {
    doThirdThing(newResult, function (finalResult) {
      console.log(`得到最终结果：${finalResult}`);
    }, failureCallback);
  }, failureCallback);
}, failureCallback);
```

```js
doSomething()
  .then(function (result) {
    return doSomethingElse(result);
  })
  .then(function (newResult) {
    return doThirdThing(newResult);
  })
  .then(function (finalResult) {
    console.log(`得到最终结果：${finalResult}`);
  })
  .catch(failureCallback);
```

如果要传递，必须return。

另外扁平的写法，async/await

```js
async function thing ()  {
	try {
        const r1 = await doSomething();
    const r2 = await doThirdThing();
    console.log(r2)
    } catch (err) {
        failurecallback(err)
    }
}	
```



### 错误处理

一旦链上发生错误，就会到catch。



如果发生错误后还要处理一下， 后面继续.then



### 并发异步：

 对于多promise， 除非有依赖， 都应该使用并发。

```js
Promise.all([func1(), func2(), func3()]).then(([result1, result2, result3]) => {
  /* 使用 result1、result2 和 result3 */
});
```





promise三种状态：pending，fulfilled，rejected

一旦 兑现了或者拒绝了，就会触发then

<img src="C:\Users\63517\Documents\notes\assets\image-20251218203220885.png" alt="image-20251218203220885" style="zoom:50%;" />





```js
const myPromise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("foo");
  }, 300);
});

myPromise
  .then(handleFulfilledA, handleRejectedA)
  .then(handleFulfilledB, handleRejectedB)
  .then(handleFulfilledC, handleRejectedC);
```







## 网络请求

fetch：普通接口

xhr： 文件上传，进度











### xhr

- 最早的异步请求，
- 事件多
- 回调驱动

```js
// 创建 XMLHttpRequest 对象
var xhr = new XMLHttpRequest();

// 配置请求 true表示异步
xhr.open('GET', 'https://api.example.com/data', true);

// 设置请求头（如果需要的话）
// xhr.setRequestHeader('Content-Type', 'application/json');

// 定义回调函数
xhr.onload = function () {
    if (xhr.status >= 200 && xhr.status < 300) {
        // 请求成功，处理响应
        console.log('Response:', xhr.responseText);
    } else {
        // 处理错误
        console.error('Error:', xhr.statusText);
    }
};

// 处理网络错误
xhr.onerror = function () {
    console.error('Request failed');
};

// 发送请求
xhr.send();
```



### fetch API

fetch基于promise对象。表示异步结果



https://www.runoob.com/ajax/fetch-api.html

现代通常使用fetch代替了xhrrequest： 

1. 通用的Request 和 Response 对象
2. fetch返回一个promise，直到服务器响应，变为response

fetch不会因为HTTP错误码 400 500 这些而被拒绝， 只有在请求没有完成才会拒绝。



## formdata

`append(name,value,filename)`

`append(name, value)`

这两个都行，上传文件使用第一个



## blob

blob意为内存中“文件”，只是一堆字节。 他没有路径，没有名字。

只有类型和大小。

*.type* 是mime类型。 浏览器判断的。

比如

```js
const blob = new Blob(['heello'], {type:'text/plain'})
```

在表单提交文件 时候，会自动识别类型

# HTTP

## cors 跨域资源共享

https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Guides/CORS#%E9%99%84%E5%B8%A6%E8%BA%AB%E4%BB%BD%E5%87%AD%E8%AF%81%E7%9A%84%E8%AF%B7%E6%B1%82

**服务器标识HTTP头** 以允许 其他源(域/协议/端口) 可以 访问自己的资源。（这还会通过cors预检服务）





### cors预检

**cors预检请求**：检查服务器是否支持cors，以及特定的方法。

在一些必要场景下，浏览器会自动发出预检请求，开发者不需要自己发出。

如DELETE请求，服务器会先发送预检:

```http
OPTIONS /resource/foo
Access-Control-Request-Method: DELETE
Access-Control-Request-Headers: origin, x-requested-with
Origin: https://foo.bar.org
```

在服务器响应该预检请求后，返回响应

```http
HTTP/1.1 200 OK
Content-Length: 0
Connection: keep-alive
Access-Control-Allow-Origin: https://foo.bar.org
Access-Control-Allow-Methods: POST, GET, OPTIONS, DELETE
Access-Control-Max-Age: 86400
```



### 场景

不是所有的跨域请求都需要。

#### 简单请求不会触发cors预检：

- GET, HEAD, POST方法
- 一些人为字段：
  - ACCEPT, 
  - Content-Type：text/plain 或者 multipart/form-data 或者 application/X-www-form-urlencoded

在简单请求下，请求origin标头自动添加， 服务端返回`Access-Control-Allow-Origin: *` 表示这个资源可以被任意源访问。

#### 附带身份凭证的请求

身份凭证：cookie, TLS客户端证书，包含用户名密码的认证标头。

默认情况下，这些凭据不会在跨源请求中发送。可以通过2种方式：

- fetch构造request时候，指定`credentials:inclue`
- XHR时候，指定`withCredentials:true`

如果是预检请求，不会包含凭证，预检响应Access-Control-Allow-Credentials:true， 实际请求携带凭证。

如果请求没有预检，请求包含凭证，预检响应Access-Control-Allow-Credentials:true，

服务器对带凭证请求的响应，标头不能设置 通配符*

- *Access-Control-Allow-Origin:特定域* 
- *Access-Control-Allow-Headers:*
- *Access-Control-Allow-Methods*
- *Access-Control-Expose-Headers*

### HTTP请求头

- *Origin*
- *Access-Control-Request-Method* 用于预检请求，想要的方法
- *Access-Control-Request-Headers:*



## content-type

https://www.runoob.com/http/http-content-type.html

- *multipart/form-data* 表单中有上传文件使用
- *x-www-form-urlencoded* 普通表单
- *application/json* 普通json
