# 未归2类

1. 数组不支持变量定义数组大小，如下：未初始化数组错误。只能通过编译时常量#define 定义
     size_t maxlineLen = 128;
       char line[maxlineLen] = {0};
2. 为啥有puts没有gets? 被废除了，不安全。可以使用fgets, getline这类限制大小。一般使用后者不保留\n
3. 读写函数中有哪些外部分配，有哪些内部分配？ 内部分配的：getline 外部分配的：fgets
4. 一直strtok会发生什么？
     • 最后返回null
       • 原始字符串破坏了，替换为\0
5. fork子进程分支如果没有exit会发生什么？是必须的嘛？ 是的，会发生未定义行为，且会进入父亲代码。
6. 打印没有结尾\0的 char*printf("%.*s", len, ptr); // 打印指定长度。 常用于前面指示len的场景
7. compare mem: mem
8. byte & 128 != 0
9. stdarg.h
10. (union P4_t){0} 属于C99风格，创建一个匿名的 union p4_t示例，初始化联合体为0. 等价于Union p4_t tmp; tmp.i = 0;
11. 警惕浅拷贝：`struct A a = s->a;`
12. 
13. `*p++` 先取值，再自增

- 自增优先级高于 取值 。
- 但是后置自增会在表达式结束后自增。 
- 如果要先自增,` *(++p) ` 
- `*(p++)` 没什么变化，因为括号只是限定了优先级。

14. 

# 基本

- switch作用域， case不加{} 就是全switch作用域
- case击穿： 比如STATE_FULLSYNC或者STATE_APPENDSYNC， 紧跟着数据，我希望从这两个状态直接跳到对应分之， 而不是重新switch。
  - 状态机，如果case内部发生状态改变，应该while

# 数据类型

- `long long` 和 `long`

  - `long` ：是机器字长语义；表示一个和指针 一样大小的整数。
  - `long long` :跨平台语义；表示一个 64位整数
  - 所以主要区别就是平台。
    - 在 linux-64。都是8字节
    - 在windows上。long是4字节

- `void* ptr`可以表示那些数据？

  在Linux-64上面，`void*` 为8字节。因此可以表示：`char,short,int,long,double`

# 时间

CPU时间：程序占用CPU时间。clock_t ，long毫秒级。 

正常时间：

- 微秒级(*microseconds*)：`struct timeval` `gettimeofday()`
- 纳秒级：struct timespec；clock_gettime()
- 秒级：`time_t`, `struct tm`

1. 时间戳转换为字符串？
  - ctime(time_t *) ：固定格式，带换行。快速使用
  - 如果要转为指定格式字符串，要先转为struct tm。
2. time_t和struct tm转换：
    • 时间戳转为tm结构：localtime() gmtime()UTC的
3. tm转字符串：
    • strftime()
4. 屏幕刷新频率？
    • 使用usleep实现，0.1s, 0.2秒感知用户输入
    重载冗杂
    sizeof并不是一个函数，而是一个操作符。
    • 操作数是变量：不必加括号。 sizeof *p 获取p指针指向对象的字节数
    • 操作数是类型：必须加括号。sizeof(int) *p。 这里含义是什么？ 强制转换int型之后 sizeof？还是int长度乘以p？ 实践：是后者。

```c
int main(){ 
    char a = '5';
    int* p = &a;                      
    int q = sizeof(int) * p;          
    printf("%d", q);                  
    return 0;                         
 }
```

# 字符串

- `strdup` 动态分配的，需要释放

- `strtok`

  - 注意：不要同时使用。`strtok`会维护一个全局变量

  ```c
  char* s1_tok = strtok(s1, "/");
  char* s2_tok = strtok(s2, "/");
  s1_tok = strtok(NULL, "/");
  s2_tok = strtok(NULL, "/");
  ```

- `strcat`原地追加


- 字符串转数字：`atoi` , `strtoll` , `sscanf`

  ```c
  const char* p = "21\r\n";
  const char* endp;
  long long v = strtoll(p, &endp, 10); 
  ```

  - `strtoll` : *endp*指向第一个非数字字符；*10*表示进制；溢出会设置`ERANGE`

- `strstr`

与字符串对应的一些内存操作：字符串内包含 *\0* 经常见到。


- `memchr`: 
- `memset`
- `memcpy`





# 结构体

## 柔性数组

- 必须作为结构体最后一个字段。 

- 问题，redis ziplist 压缩列表希望柔性数组后面再来一个zlend末尾标记，这就会冲突！
  ```c
  typedef struct {
    unsigned int zlbytes;  // 压缩列表总字节数
    unsigned int zltail;   // 到最后一个节点的偏移量
    unsigned short zllen;  // 压缩列表中节点数
    unsigned char entries[]; // 节点数据（变长）
  unsigned int zlend;
  } ziplist;
  ```

  解决：额外检测zlend字段，创建内存时候，加上zlend字节。但是结构不包含

## 向前声明

头文件嵌套问题，可以定义*typedefs.h* 

```c
typedef struct ConnectionListener ConnectionListener;

typedef struct {
    int fd;
    ConnectionListener *listener;
    // 其他字段
} Connection;

struct ConnectionListener {
    int port;
    char *bindAddr;
    Connection *conn;
};
```

### 引起的问题，“封装”：

*pointer or reference to incomplete type "struct Pager" is not allowed C/C++(833)*

```c
// pager.h
typedef struct Pager pager;

// pager.c
struct Pager {
    int size;
};
// main.c
#include "pager.h"
Pager* p;
p->size; 
```

在pager.c之外，不能直接获取字段，无法感知。只能通过函数接口访问。

```c
// pager.c
int pager_get_size(Pager* p)
{
    return p->size;
}
```


如果pager 作为一个模块，还有page1.c 等模块内部文件，需要直接访问属性。常常我们使用pagerInt.h作为内部头文件，提供结构体完整定义。而pager.h作为对外头文件，提供向前声明，封装。

## 强制结构体/变量对齐

场景：现在pool结构后面，要跟数据区域。但是整个内存要求8字节对齐，pool结构lock属性尺寸不能保证是8字节对齐的。

```c
typedef struct {
    // meta
    uint32_t magic;
    uint32_t version;
    uint32_t cap;
    uint32_t used;
    // 
    FreeBlock freeListHead; // 空闲链表头
    //
    pthread_mutex_t lock; // 内存池锁
    // data
} Pool; 
```

解决： __attribute__((aligned(8))) 是编译器的扩展语法，能够强制结构体/变量对齐。 这个叫编译器属性，不是C语言语法或者宏，一般我们通过宏展开添加

```c
#define ALIGN8 __attribute__((aligned(8))) 
__attribute__((aligned(8))) struct pool {

}; 
int x __attribute__((aligned(16)))`
```

## 位字段

- 官方标准是*int , unsigned int ，signed int*, 没有 `unsigned char`

## 一次声明

struct A {};   // 定义类型 A
struct A a1;   // 创建变量 a1
struct {} a2;  // 匿名 struct，变量是 a2，不能再创建相同类型变量。  常用在结构体字段内。



# IO



## 格式化IO

### scanf

`fscanf`, `scanf`,`sscanf`

- ...

### printf

- `%c`,：*unsigned char*
- `%d`, 
- `%u` , `%o`, `%x`,`%X` : *unsigned int*
- `%e` ,`%E`：*double*
- `%f`, `%g`, `%G`：*double*
- `%s`
- `%p`：*void* *
- `%n`：*int* *
- `%h_` ： *short*
- `%l_`：*long*
- `%L_`：*long double*



​	snprintf 返回打印的字符数。 printf行缓冲行为。默认遇到\n或者缓冲区满才会刷新的标准输出。程序推出前会自动fflush(stdout)。
​	 下面代码， printf不会打印。因为行缓冲。

```c
int main(int argc, char const *argv[])
{
    PoolContext ctx = {NULL,-1};
    pool_create(&ctx);
    printf("??");
    signal(SIGINT, sigintHandler); // CTRL+C
    void* ptr=  pool_alloc(16, &ctx);
    uint64_t* cp = (uint64_t*)ptr;
    *cp = 0XFFFFFFFFFFFFFFFF; // 测试写入
    // pool_free(ptr, &ctx);
    while (!stop) {
    	sleep(1);
    }
    puts("stopped");
    pool_close(&ctx);
    pool_cover(&ctx);
    pool_destroy(&ctx);
    return 0;
}  
```

# GLIB

​	GLIB文档 glib是跨平台的C工具库。相关地，glibc(GNU C)是linux的标准C库，linux运行基础。
​	C标准分为语法和实现。
​	• C标准库：就是一组标准头文件，规定实现含义。
​	• C运行库：各平台自己实现，并添加一些扩展。比如LINUX的glibc和MS的MSVCRT glib有6个主要模块：
​	• GObject：面向对象特性：继承、信号、属性等
​	• GIO：IO抽象（文件、流、网络）
​	• GLib：基础工具。高级数据结构、内存管理、字符串处理、时间等
​	• GModule: 跨平台动态加载模块接口？
​	• GThread: 跨平台线程API和线程池支持。
​	• GMainLoop：事件循环机制。 GTree 平衡二叉搜索树

# 随机

​	整数：
​	int x = rand() % 100;         // 0~99
​	浮点：
​	double r = rand() / (double)RAND_MAX;          // [0, 1)
​	double r2 = 90.0 + r * 20.0;                   // [90.0, 110.0)
​	时间种子：
​	srand((unsigned(time(NULL))
​	随机字符：
​	char c = 'A' + rand() % 26;
​	布尔值：
​	bool b = rand() & 1;

## ncurses

​	关于界面刷新和用户按键。 用户按键按下是有时长的， 如果1秒界面刷新，即意味着只有间隔1s才检测。 如果0.1秒，那就是每秒检测10次。显然会流畅很多。
安全信号处理
​	volatile sig_atomic_t stop = 0; sig_atomic_t 类型表示 对于数据的访问不会被信号中断。 volatile 用于告知编译器，该变量的值可能会在编译器无法察觉的情况下被修改（例如，由信号处理程序修改）。防止编译器不必要优化，每次都从内存读取，不可使用缓存。
​	signal(SIGINT, sigintHandler); // CTRL+C
​	while (!stop) {
​	

	}
	// 资源清理
## 退出程序

- return-main		正常退出，会执行atexit() 注册的清理函数。

- exit(int status)	库或者子函数主动退出	立即终止程序，会执行atexit() 注册的清理函数。
- _exit(status)	fork子进程出错调用	立即终止，不清理，不刷新缓冲。

- abort()	致命错误，如断言失败	异常终止，不清理，不刷新缓冲
- raise(SIGTERM); 		信号方式的自杀式终止，触发信号处理程序

# 指针

​	void*不允许加减，比如内存池通过offset + base指针定位需要转为char*
​	

## 函数指针，函数类型：

- 方法1：
  定义一个函数类型：`typedef void callback(struct EventLoop* evp, void* data); `
  指向一个函数的指针：`callback* call;` 等价于`void (*call)(struct EventLoop* evp, void* data);`

- 方法2：更推荐
  定义一个函数指针类型：`typedef void (*callback)(struct EventLoop* evp, void* data);`
  声明一个函数指针类型变量：`callback call`等价于`void (*call)(struct EventLoop* evp, void* data)`

- 赋值：
  **函数名直接赋值**，赋值对象是指针：`callptr = myfunc;`等价于显示取地`callptr = &myfunc`
  但不能的是 calltype = myfunc;❌

- 结构体中形式：
  ```c
  typedef struct
  {
  int (*parse)(void *ctx, sds *buf);  // Parse from net read. Out to upper.
  int (*encode)(void *ctx, sds *buf); // Encode from upper. Out to net.
  } proto_handler_t;
  ```

## 优先级

​	&p->r取结构体成员地址。等价于&(p->r) == &((*p).r)
​	*p->r访问结构体成员内容。等价于*(p->r)

## 整数和void*

​	一般对于端口小型整数。
​	int callback(void* arg)
​	{
​	int port = (intptr_t)arg;
​	}
​	int port =9988;
​	callback((void*)(intptr_t)port);
​	size_t *selectsize = malloc(sizeof(size_t)); *selectsize = 0; // 正确
​	对指针指向值赋值，必须指针指向一个有效内存，如& 或者 malloc

## 数组和指针

从《C Expert》角度来看。数组名和指针互换。

有两类情况：声明和使用。

1. 声明：外部数组extern声明； 数组定义（定义是声明的特殊情况）；函数参数声明；
   只有在函数参数的情况下，数组形式和指针形式等价。func(char a[]);等价于func(char* a);

1. 使用：即在表达式中使用。数组形式和指针形式等价。c = a[i];等价与
  常见例子：

2. 在函数调用时候，数组名和指针都行
  ```c
  char arr1[10];
  char *arr2;
  //...
  i = strlen(arr1);
  j = strlen(arr2);
  printf("%s %s", arr1, arr2);
  printf("array LOC: %x, content : %s", a, a);
  ```

  这个是成立的， 作为函数调用，传到printf都是指针传递。
  int main1(int argc, char** argv);
  int main2(int argc, char* argv[]);

  

  **‼ ANSI C RULES：**

  - 表达式中的**数组名被编译器当作一个指向该数组第一个元素的指针。**
  - 下标总是与偏移量相同。
  - 在函数参数的声明中，数组名被编译器当作一个指向该数组第一个元素的指针。
  - 对数组下标的引用总是可以写成一个指向数组初始地址的指针加上偏移量。对数组的引用如a[i] 在编译时候总是被改写为*(a + i)。

  **!!例外:极少见情况。不能用指向第一个数组元素的指针 来等价 数组名**

  - sizeof(arr) 这里是整个数组大小。而不是指针的大小
  - &arr取数组的地址。 ???
  - 数组是一个字符串常量初始值。



# 设计

## 注册-回调解耦机制

​	每一层对下层直接调用，对上层进行回调。
​	A暴露函数声明，B实现&注册，A调用。

## FSM状态机

- if-else,  *switch*
- FSM + entry action

# 编译&链接&运行

***a.out:  assembler output*** 汇编程序。 通常是ELF格式。是二进制文件，不仅仅是汇编文本。

- .out可执行文件内容就是若干段：text段、data段、bss段
- size 命令查看文件内容 	

通过nm命令查看符号表；objdump -d 命令查看汇编。



## nm命令

```c
#include <stdlib.h>
char pear[40];	// 全局，未初始化 => BSS
static double peach; // 文件内，未初始化 => bss
int mango = 123;	// 全局，已初始化 => DATA
static long melon = 2001;	// 文件内，已初始化 => data

int main(int argc, char const *argv[])	// 文本段
{
int i = 3, j, *ip; // 局部变量不在.out文件，而是在运行时创建
ip = malloc(sizeof(i));	// 文本段
pear[5] = i; // 文本段
peach = 2.0 * mango; // 文本段
return 0; // 文本段
}
```

**nm命令说明**
<地址> <符号类型> <符号>
T：文本段
D：数据段已初始化的
B：bss段未初始化的
R：只读数据。 .rodata段
U：未定义符号，从其他库文件解析
W：弱符号，可被其他符号覆盖
大写：全局可见
小写：文件内可见。
**地址**
在目标文件.o中：地址是段内偏移。
在可执行文件中：地址是链接器分配的虚拟地址，通常从0x400000开始。
在程序运行时：地址是真的物理地址（虚拟地址=>“真实”地址）

## objdump -d 查看汇编

为什么是段？
链接器可以直接把文件段内容通过mmap直接映射加载到内存。这样内存里面就是很多个的段空间。