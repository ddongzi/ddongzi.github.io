# Boost.Asio

> asio为C++网络框架，但是文档和一些书籍内容复杂，乱七八糟。需要自己整理下。

https://mmoaay.gitbooks.io/boost-asio-cpp-network-programming-chinese/content/Chapter1.html

## 入门

说明asio网络编程几个重要的点

### 同步和异步的选择

同步编程中，所有操作是顺序执行。如对一个socket，读-处理-写入，每个操作都是阻塞的。这意味着我们往往需要每个socket需要一个线程，即多线程服务端。

异步编程中，只需要为动作注册回调，执行完即调用回调，因为，服务端只要一个线程。

同步编程通过消耗更多资源让语义简单，异步编程则是赋予更大的编程难度让资源消耗更少。

一个同步服务端例子：

### 异常错误

都使用`boost::system::system_error`类型表示。

两种获取捕获错误的方式等价：

```c++
try {
	sock.connect(ep);
} catch (boost::system::system_error e) {
    std::cout<< e.code() << endl;
}
```

```c++
boost::system::system_error err;
sock.connect(ep, err);
if (err) 
    std::cout << err.code() << endl;
```

在异步编程中，通过回调返回的错误码得知。



### 线程

- io_service/io_context是线程安全的：多个线程调用`io_service.run()`各不影响，
- socket不是线程安全的：一个线程读socket时候，另外线程可以写，内部状态不稳定



### 其他IO功能

支持信号量。

```c++
boost::signal_set sig(service, SIGINT, SIGTERM);
sig.async_wait(signal_handler);
```

### 计时器

有一些异步IO需要设置timeout。同步IO当然没有阻塞超时的概念。



### io_service类

通常会写几个io_service实例，负责与操作系统打交道，等待异步操作结束，为异步执行回调



### 宏





## Boost.Asio基本原理

当有了异步编程，很多事情变得复杂有趣了。

### 命名空间

- *boost:asio* ：核心 io_service， read, async_read ...
- *boost::asio::ip*: 通信。address，endpoint,tcp,udp,icmp; connect,async_connect.
- *boost::asio::error*: 错误码



### ip地址处理

`ip::address addr = ip::address::from_string("127.0.0.1");`

这个函数参数不能是host，如`ip::address::from_string("baidu.com")`是错误的



### endpoint

端口和连接的地址组成了endpoint端点。

`ip::address::endpoint ep(ip::address::from_string("127.0.0.1"), 80);` 客户端连接 本地80端点。

`ip::address::endpoint ep(ip::tcp::v4(), 80);` 服务端创建 本地80监听



### socket

endpoint静态表示一个位置，socket则是动态的具有生命的东西。

```c++
io_service service;
ip::udp::socket sock(service);
sock.set_option(ip::udp::socket::reuse_address(true));
```

#### socket连接相关函数：

- *open* 在服务端或者UDP使用，打开一个套接字
- *bind*
- *connect*
- *async_connect*
- *close*
- *shutdown* 指定套接字上send或者receive立马失效
- *cancel* 取消套接字上所有的异步操作，异步操作立即结束，返回aborted错误码

```c++
ip::tcp::endpoint ep(ip::address::from_string("127.0.0.1"), 80);
ip::tcp::socket sock(service);
sock.open(ip::tcp::v4())；
sock.connect(ep);
sock.write_some(buffer("GET /index.html\r\n"));
char buf[1024];
sock.read_some(buffer(buf, 1024));
sock.shutdown(ip::tcp::socket::shutdown_receive)；
sock.close();

```

#### socket读写相关



### 同步函数错误码

每个同步函数都有带错误码参数的重载。



